<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">



  
  
  <link rel="stylesheet" href="/lib/Han/dist/han.min.css?v=3.3">



  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">











  
  
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">







<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat_32px_1165145_easyicon.net.ico?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/cat_16px_1165145_easyicon.net.ico?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: true,
    fastclick: true,
    lazyload: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '5HERDWLKZV',
      apiKey: '7876dff207d78e6df0721656b26ee0af',
      indexName: 'hexo-algolia',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="C 语言进阶一、 内存分区栈区  由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。">
<meta name="keywords" content="c&#x2F;c++">
<meta property="og:type" content="article">
<meta property="og:title" content="C 进阶">
<meta property="og:url" content="http://miaopei.github.io/2016/05/24/Program-C/program-c-advance/index.html">
<meta property="og:site_name" content="Mr.Miaow Blog">
<meta property="og:description" content="C 语言进阶一、 内存分区栈区  由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://miaopei.github.io/images/imageProgramC/函数调用流程.png">
<meta property="og:image" content="http://miaopei.github.io/images/imageProgramC/栈的生长方向和内存存放方向.png">
<meta property="og:image" content="http://miaopei.github.io/images/imageProgramC/二级指针.png">
<meta property="og:image" content="http://miaopei.github.io/images/imageProgramC/文件读写案例.png">
<meta property="og:image" content="http://miaopei.github.io/images/imageProgramC/链表.png">
<meta property="og:image" content="http://miaopei.github.io/images/imageProgramC/链表-01.png">
<meta property="og:image" content="http://miaopei.github.io/images/imageProgramC/链表-02.png">
<meta property="og:image" content="http://miaopei.github.io/images/imageProgramC/链表-03.png">
<meta property="og:image" content="http://miaopei.github.io/images/imageProgramC/链表-04.png">
<meta property="og:image" content="http://miaopei.github.io/images/imageProgramC/链表-05.png">
<meta property="og:image" content="http://miaopei.github.io/images/imageProgramC/链表-06.png">
<meta property="og:image" content="http://miaopei.github.io/images/imageProgramC/条件编译.png">
<meta property="og:image" content="http://miaopei.github.io/images/imageProgramC/递归函数.png">
<meta property="og:image" content="http://miaopei.github.io/images/imageProgramC/递归函数-01.png">
<meta property="og:updated_time" content="2019-06-14T06:13:11.551Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C 进阶">
<meta name="twitter:description" content="C 语言进阶一、 内存分区栈区  由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。">
<meta name="twitter:image" content="http://miaopei.github.io/images/imageProgramC/函数调用流程.png">



  <link rel="alternate" href="/atom.xml" title="Mr.Miaow Blog" type="application/atom+xml">



  
  
  <link rel="canonical" href="http://miaopei.github.io/2016/05/24/Program-C/program-c-advance/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>C 进阶 | Mr.Miaow Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mr.Miaow Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">Do what you say, say what you do.</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-messages">

    
    
    
      
    

    

    <a href="/messages/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>留言板</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-top">

    
    
    
      
    

    

    <a href="/top/" rel="section"><i class="menu-item-icon fa fa-fw fa-signal"></i> <br>阅读Top</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  
    <div class="reading-progress-bar"></div>
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://miaopei.github.io/2016/05/24/Program-C/program-c-advance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Miaow">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://wx4.sinaimg.cn/orj360/e9d04169ly1fde7jy4bquj20ek0hf7gh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Miaow Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">C 进阶

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-05-24 10:14:50" itemprop="dateCreated datePublished" datetime="2016-05-24T10:14:50+08:00">2016-05-24</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/c-c/" itemprop="url" rel="index"><span itemprop="name">c/c++</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/05/24/Program-C/program-c-advance/" class="leancloud_visitors" data-flag-title="C 进阶">
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
            </span>
            
                <span class="post-meta-item-text">阅读次数：</span>
                <!--<span class="post-meta-item-text">阅读次数：</span>-->
            
            <span class="leancloud-visitors-count"></span>
            </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">23k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">92</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <h1 id="C-语言进阶"><a href="#C-语言进阶" class="headerlink" title="C 语言进阶"></a>C 语言进阶</h1><h2 id="一、-内存分区"><a href="#一、-内存分区" class="headerlink" title="一、 内存分区"></a>一、 内存分区</h2><p>栈区</p>
<ul>
<li>由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。</li>
</ul>
<a id="more"></a>

<p>堆区</p>
<ul>
<li>由编程人员手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。使用malloc或者new进行堆的申请。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">功能：在内存动态存储区中分配nmemb块长度为size字节的连续区域。<span class="built_in">calloc</span>自动将分配的内存置<span class="number">0</span>。</span><br><span class="line">参数：</span><br><span class="line">	nmemb：所需内存单元数量</span><br><span class="line">	size：每个内存单元的大小（单位：字节）</span><br><span class="line">返回值：</span><br><span class="line">	成功：分配空间的起始地址</span><br><span class="line">	失败：<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">功能：重新分配用<span class="built_in">malloc</span>或者<span class="built_in">calloc</span>函数在堆中分配内存空间的大小。<span class="built_in">realloc</span>不会自动清理增加的内存，需要手动清理，如果指定的地址后面有连续的空间，那么就会在已有地址基础上增加内存，如果指定的地址后面没有空间，那么<span class="built_in">realloc</span>会重新分配新的连续内存，把旧内存的值拷贝到新内存，同时释放旧内存。</span><br><span class="line">参数：</span><br><span class="line">	ptr：为之前用<span class="built_in">malloc</span>或者<span class="built_in">calloc</span>分配的内存地址，如果此参数等于<span class="literal">NULL</span>，那么和<span class="built_in">realloc</span>与<span class="built_in">malloc</span>功能一致</span><br><span class="line">	size：为重新分配内存的大小, 单位：字节</span><br><span class="line">返回值：</span><br><span class="line">	成功：新分配的堆内存地址</span><br><span class="line">	失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<p>全局/静态区</p>
<ul>
<li><p>全局静态区内的变量在编译阶段已经分配好内存空间并初始化。这块内存在程序运行期间一直存在,它主要存储<strong>全局变量</strong>、<strong>静态变量</strong>和<strong>常量</strong>。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>这里不区分初始化和未初始化的数据区，是因为静态存储区内的变量若不显示初始化，则编译器会自动以默认的方式进行初始化，即静态存储区内不存在未初始化的变量。</li>
<li>全局静态存储区内的常量分为常变量和字符串常量，一经初始化，不可修改。静态存储内的常变量是全局变量，与局部常变量不同，区别在于局部常变量存放于栈，实际可间接通过指针或者引用进行修改，而全局常变量存放于静态常量区则不可以间接修改。</li>
<li>字符串常量存储在全局/静态存储区的常量区。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v1 = <span class="number">10</span>;<span class="comment">//全局/静态区</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> v2 = <span class="number">20</span>; <span class="comment">//常量，一旦初始化，不可修改</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> v3 = <span class="number">20</span>; <span class="comment">//全局/静态区</span></span><br><span class="line"><span class="keyword">char</span> *p1; <span class="comment">//全局/静态区，编译器默认初始化为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//那么全局static int 和 全局int变量有什么区别？</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> v4 = <span class="number">20</span>; <span class="comment">//全局/静态区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字符串常量是否可修改？字符串常量优化</strong>：</p>
<table>
<thead>
<tr>
<th>ANSI C中规定：修改字符串常量，结果是未定义的。<br>ANSI C并没有规定编译器的实现者对字符串的处理，例如：<br>1. 有些编译器可修改字符串常量，有些编译器则不可修改字符串常量。<br>2. 有些编译器把多个相同的字符串常量看成一个（这种优化可能出现在字符串常量中，节省空间），有些则不进行此优化。如果进行优化，则可能导致修改一个字符串常量导致另外的字符串常量也发生变化，结果不可知。<br><strong>所以尽量不要去修改字符串常量</strong>！</th>
</tr>
</thead>
<tbody><tr>
<td>C99标准：<br>char <em>p = “abc”; defines p with type ‘‘pointer to char’’ and initializes it to point to an object with type ‘‘array of char’’ with length 4 whose elements are initialized with a character string literal. *</em>If an attempt is made to use p to modify the contents of the array, the behavior is undefined**.</td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<p>在理解C/C++内存分区时，常会碰到如下术语：数据区，堆，栈，静态区，常量区，全局区，字符串常量区，文字常量区，代码区等等，初学者被搞得云里雾里。在这里，尝试捋清楚以上分区的关系。</p>
<p><strong>数据区包括</strong>：堆，栈，全局/静态存储区。</p>
<p><strong>全局/静态存储区包括</strong>：常量区，全局区、静态区。</p>
<p><strong>常量区包括</strong>：字符串常量区、常变量区。</p>
<p><strong>代码区</strong>：存放程序编译后的二进制代码，不可寻址区。</p>
<p><strong>可以说，C/C++内存分区其实只有两个，即代码区和数据区</strong>。</p>
<p>函数调用模型：</p>
<ul>
<li>在经典的操作系统中，栈总是向下增长的。压栈的操作使得栈顶的地址减小，弹出操作使得栈顶地址增大。</li>
</ul>
<p>栈在程序运行中具有极其重要的地位。最重要的，栈保存一个函数调用所需要维护的信息，这通常被称为堆栈帧(Stack Frame)或者活动记录(Activate Record).一个函数调用过程所需要的信息一般包括以下几个方面：</p>
<ul>
<li>函数的返回地址；</li>
<li>函数的参数；</li>
<li>临时变量；</li>
<li>保存的上下文：包括在函数调用前后需要保持不变的寄存器。</li>
</ul>
<img src="/images/imageProgramC/函数调用流程.png">

<p>栈的生长方向和内存存放方向：</p>
<img src="/images/imageProgramC/栈的生长方向和内存存放方向.png">

<h2 id="二、指针强化"><a href="#二、指针强化" class="headerlink" title="二、指针强化"></a>二、指针强化</h2><p><strong>指针是一种数据类型，占用内存空间，用来保存内存地址</strong>。</p>
<h3 id="2-1-野指针和空指针"><a href="#2-1-野指针和空指针" class="headerlink" title="2.1 野指针和空指针"></a>2.1 野指针和空指针</h3><h4 id="2-1-1-空指针"><a href="#2-1-1-空指针" class="headerlink" title="2.1.1 空指针"></a>2.1.1 空指针</h4><p>标准定义了NULL指针，它作为一个特殊的指针变量，表示不指向任何东西。要使一个指针为NULL,可以给它赋值一个零值。为了测试一个指针百年来那个是否为NULL,你可以将它与零值进行比较。</p>
<p>对指针解引用操作可以获得它所指向的值。但从定义上看，NULL指针并未执行任何东西，因为对一个NULL指针因引用是一个非法的操作，在解引用之前，必须确保它不是一个NULL指针。</p>
<p>如果对一个NULL指针间接访问会发生什么呢？结果因编译器而异。</p>
<p><strong>不允许向NULL和非法地址拷贝内存</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//给p指向的内存区域拷贝内容</span></span><br><span class="line">	<span class="built_in">strcpy</span>(p, <span class="string">"1111"</span>); <span class="comment">//err</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *q = <span class="number">0x1122</span>;</span><br><span class="line">	<span class="comment">//给q指向的内存区域拷贝内容</span></span><br><span class="line">	<span class="built_in">strcpy</span>(q, <span class="string">"2222"</span>); <span class="comment">//err		</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-野指针"><a href="#2-1-2-野指针" class="headerlink" title="2.1.2 野指针"></a>2.1.2 野指针</h4><p><strong>在使用指针时，要避免野指针的出现</strong>：</p>
<p>野指针指向一个已删除的对象或未申请访问受限内存区域的<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzE1OTQxNy5odG0=" title="http://baike.baidu.com/view/159417.htm">指针<i class="fa fa-external-link"></i></span>。与空指针不同，野指针无法通过简单地判断是否为 <span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzMyOTQ4NC5odG0=" title="http://baike.baidu.com/view/329484.htm">NULL<i class="fa fa-external-link"></i></span>避免，而只能通过养成良好的编程习惯来尽力减少。对野指针进行操作很容易造成程序错误。</p>
<p><strong>什么情况下会导致野指针</strong>？</p>
<ul>
<li><p><strong>指针变量未初始化</strong></p>
<ul>
<li>任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</li>
</ul>
</li>
<li><p><strong>指针释放后未置空</strong></p>
<ul>
<li>有时指针在free或delete后未赋值 NULL，便会使人以为是合法的。别看free和delete的名字（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。</li>
</ul>
</li>
<li><p><strong>指针操作超越变量作用域</strong></p>
<ul>
<li><strong>不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放</strong>。</li>
</ul>
</li>
</ul>
<p><strong>操作野指针是非常危险的操作，应该规避野指针的出现</strong>：</p>
<ul>
<li><p><strong>初始化时置 NULL</strong></p>
<ul>
<li>指针变量一定要初始化为NULL，因为任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的。</li>
</ul>
</li>
<li><p><strong>释放时置 NULL</strong></p>
<ul>
<li>当指针p指向的内存空间释放时，没有设置指针p的值为NULL。delete和free只是把内存空间释放了，但是并没有将指针p的值赋为NULL。通常判断一个指针是否合法，都是使用if语句测试该指针是否为NULL。</li>
</ul>
</li>
</ul>
<p><strong>用指针作为函数返回值时需要注意的一点是，函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针请尽量不要指向这些数据</strong>，C语言没有任何机制来保证这些数据会一直有效，它们在后续使用过程中可能会引发运行时错误。请看下面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = func(), n;</span><br><span class="line">    n = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"value = %d\n"</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p> n 是 func() 内部的局部变量，func() 返回了指向 n 的指针，根据上面的观点，func() 运行结束后 n 将被销毁，使用 <code>*p</code> 应该获取不到 n 的值。但是从运行结果来看，我们的推理好像是错误的，func() 运行结束后 <code>*p</code> 依然可以获取局部变量 n 的值，这个上面的观点不是相悖吗？</p>
<p>为了进一步看清问题的本质，不妨将上面的代码稍作修改，在第9~10行之间增加一个函数调用，看看会有什么效果：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = func(), n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c.biancheng.net\n"</span>);</span><br><span class="line">    n = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"value = %d\n"</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.biancheng.net</span><br><span class="line">value = <span class="number">-2</span></span><br></pre></td></tr></table></figure>

<p>可以看到，现在 p 指向的数据已经不是原来 n 的值了，它变成了一个毫无意义的甚至有些怪异的值。与前面的代码相比，该段代码仅仅是在 <code>*p</code> 之前增加了一个函数调用，这一细节的不同却导致运行结果有天壤之别，究竟是为什么呢？</p>
<p>前面我们说函数运行结束后会销毁所有的局部数据，这个观点并没错，大部分C语言教材也都强调了这一点。但是，这里所谓的销毁并不是将局部数据所占用的内存全部抹掉，而是程序放弃对它的使用权限，弃之不理，后面的代码可以随意使用这块内存。对于上面的两个例子，func() 运行结束后 n 的内存依然保持原样，值还是 100，如果使用及时也能够得到正确的数据，如果有其它函数被调用就会覆盖这块内存，得到的数据就失去了意义。</p>
<blockquote>
<p>关于函数调用的原理以及函数如何占用内存的更多细节，我们将在《<span class="exturl" data-url="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC9jcHAvdS9jMjAv" title="http://c.biancheng.net/cpp/u/c20/">C语言和内存<i class="fa fa-external-link"></i></span>》专题中深入探讨，相信你必将有所顿悟，解开心中的谜团。</p>
</blockquote>
<p>第一个例子在调用其他函数之前使用 <code>*p</code> 抢先获得了 n 的值并将它保存起来，第二个例子显然没有抓住机会，有其他函数被调用后才使用 <code>*p</code> 获取数据，这个时候已经晚了，内存已经被后来的函数覆盖了，而覆盖它的究竟是一份什么样的数据我们无从推断（一般是一个没有意义甚至有些怪异的值）。</p>
<p><strong>总结</strong>：</p>
<p>常规程序中，函数返回的指针通常应该是：</p>
<ul>
<li>指向静态（static）变量；</li>
<li>指向专门申请分配的（如用malloc）空间；</li>
<li>指向常量区（如指向字符串”hello”）；</li>
<li>指向全局变量；</li>
<li>指向程序代码区（如指向函数的指针）。 </li>
</ul>
<p>除这5项以外，其它怪技巧不提倡。</p>
<p><strong>函数内的变量，没有关键字static修饰的变量的生命周期只在本函数内，函数结束后变量自动销毁</strong>。当返回为指针的时候需要特别注意，因为<strong>函数结束后指针所指向的地址依然存在，但是该地址可以被其他程序修改，里面的内容就不确定了，有可能后面的操作会继续用到这块地址，有可能不会用到，所以会出现时对时错的情况，如果需要返回一个指针而又不出错的话只能调用内存申请函数</strong></p>
<h3 id="2-2-间接访问操作符"><a href="#2-2-间接访问操作符" class="headerlink" title="2.2 间接访问操作符"></a>2.2 间接访问操作符</h3><p>通过一个指针访问它所指向的地址的过程叫做间接访问，或者叫解引用指针，这个用于执行间接访问的操作符是 <code>*</code>。</p>
<p>注意：对一个<code>int*</code>类型指针解引用会产生一个整型值，类似地，对一个<code>float*</code>指针解引用会产生了一个float类型的值。</p>
<ul>
<li><p>在指针声明时，<code>*</code> 号表示所声明的变量为指针</p>
</li>
<li><p>在指针使用时，<code>*</code> 号表示操作指针所指向的内存空间</p>
<ul>
<li><code>*</code> 相当通过地址(指针变量的值)找到指针指向的内存，再操作内存</li>
<li><code>*</code> 放在等号的左边赋值（给内存赋值，写内存）</li>
<li><code>*</code> 放在等号的右边取值（从内存中取值，读内存）</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义指针</span></span><br><span class="line">	<span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//指针指向谁，就把谁的地址赋给指针</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	p = &amp;a;</span><br><span class="line">	*p = <span class="number">20</span>;<span class="comment">//*在左边当左值，必须确保内存可写</span></span><br><span class="line">	<span class="comment">//*号放右面，从内存中读值</span></span><br><span class="line">	<span class="keyword">int</span> b = *p;</span><br><span class="line">	<span class="comment">//必须确保内存可写</span></span><br><span class="line">	<span class="keyword">char</span>* str = <span class="string">"hello world!"</span>;</span><br><span class="line">	*str = <span class="string">'m'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d\n"</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*p:%d\n"</span>, *p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b:%d\n"</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-指针的步长"><a href="#2-3-指针的步长" class="headerlink" title="2.3 指针的步长"></a>2.3 <strong>指针的步长</strong></h3><p>指针是一种数据类型，是指它指向的内存空间的数据类型。指针所指向的内存空间决定了指针的步长。指针的步长指的是，当指针+1时候，移动多少字节单位。</p>
<h3 id="2-4-指针的意义-间接赋值"><a href="#2-4-指针的意义-间接赋值" class="headerlink" title="2.4 指针的意义_间接赋值"></a>2.4 指针的意义_间接赋值</h3><p>通过指针间接赋值成立的三大条件：</p>
<ul>
<li><p>2个变量（一个普通变量一个指针变量、或者一个实参一个形参）</p>
</li>
<li><p>建立关系</p>
</li>
<li><p>通过 <code>*</code> 操作指针指向的内存</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">100</span>;	<span class="comment">//两个变量</span></span><br><span class="line">	<span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//建立关系</span></span><br><span class="line">	<span class="comment">//指针指向谁，就把谁的地址赋值给指针</span></span><br><span class="line">	p = &amp;a;</span><br><span class="line">	<span class="comment">//通过*操作内存</span></span><br><span class="line">	*p = <span class="number">22</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>间接赋值：从1级指针到2级指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AllocateSpace</span><span class="params">(<span class="keyword">char</span>** p)</span></span>&#123;</span><br><span class="line">	*p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(*p, <span class="string">"hello world!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeSpace</span><span class="params">(<span class="keyword">char</span>** p)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (*p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">free</span>(*p);</span><br><span class="line">		*p = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	AllocateSpace(&amp;p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p);</span><br><span class="line">	FreeSpace(&amp;p);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"p内存释放!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>间接赋值的推论</strong>：</p>
<ul>
<li><p>用 1 级指针形参，去间接修改了 0 级指针(实参)的值。</p>
</li>
<li><p>用 2 级指针形参，去间接修改了 1 级指针(实参)的值。</p>
</li>
<li><p>用 3 级指针形参，去间接修改了 2 级指针(实参)的值。</p>
</li>
<li><p>用 n 级指针形参，去间接修改了 n-1 级指针(实参)的值。</p>
</li>
</ul>
<h3 id="2-5-指针做函数参数"><a href="#2-5-指针做函数参数" class="headerlink" title="2.5 指针做函数参数"></a>2.5 指针做函数参数</h3><p>指针做函数参数，具备输入和输出特性：</p>
<ul>
<li><p>输入：主调函数分配内存</p>
</li>
<li><p>输出：被调用函数分配内存</p>
</li>
</ul>
<p>输入特性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *p <span class="comment">/* in */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//给p指向的内存区域拷贝内容</span></span><br><span class="line">	<span class="built_in">strcpy</span>(p, <span class="string">"abcddsgsd"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//输入，主调函数分配内存</span></span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	fun(buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"buf  = %s\n"</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出特性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> **p <span class="comment">/* out */</span>, <span class="keyword">int</span> *len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *tmp = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">strcpy</span>(tmp, <span class="string">"adlsgjldsk"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//间接赋值</span></span><br><span class="line">	*p = tmp;</span><br><span class="line">	*len = <span class="built_in">strlen</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//输出，被调用函数分配内存，地址传递</span></span><br><span class="line">	<span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	fun(&amp;p, &amp;len);</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"p = %s, len = %d\n"</span>, p, len);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-字符串指针强化"><a href="#2-6-字符串指针强化" class="headerlink" title="2.6 字符串指针强化"></a>2.6 字符串指针强化</h3><p><strong>字符串是以0或者’\0’结尾的字符数组，(数字0和字符’\0’等价)</strong></p>
<p><strong>如果以字符串初始化，那么编译器默认会在字符串尾部添加’\0’</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str3[] = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>sizeof 计算数组大小，数组包含’\0’字符</p>
</li>
<li><p>strlen 计算字符串的长度，到’\0’结束</p>
</li>
</ul>
<p>字符串拷贝功能实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1）应该判断下传入的参数是否为NULL</span></span><br><span class="line"><span class="comment">//2）最好不要直接使用形参</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_string04</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">char</span>* source)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dest == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (source == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span>* src = source;</span><br><span class="line">	<span class="keyword">char</span>* tar = dest;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*tar++ = *src++)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串的格式化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">     根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到出现字符串结束符 <span class="string">'\0'</span> 为止。</span><br><span class="line">参数： </span><br><span class="line">	str：字符串首地址</span><br><span class="line">	format：字符串格式，用法和<span class="built_in">printf</span>()一样</span><br><span class="line">返回值：</span><br><span class="line">	成功：实际格式化的字符个数</span><br><span class="line">	失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 格式化字符串</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"你好,%s,欢迎加入我们!"</span>, <span class="string">"John"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>,buf);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"我今年%d岁了!"</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 拼接字符串</span></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">"world"</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">sprintf</span>(buf,<span class="string">"%s %s"</span>,str1,str2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s len:%d\n"</span>, buf,len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 数字转字符串</span></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"%d"</span>, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line"><span class="comment">//设置宽度 右对齐</span></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"%8d"</span>, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line"><span class="comment">//设置宽度 左对齐</span></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"%-8d"</span>, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。</span><br><span class="line">参数：</span><br><span class="line">	str：指定的字符串首地址</span><br><span class="line">	format：字符串格式，用法和<span class="built_in">scanf</span>()一样</span><br><span class="line">返回值：</span><br><span class="line">	成功：实际读取的字符个数</span><br><span class="line">	失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>格式</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>%*s或%*d</code></td>
<td>跳过数据</td>
</tr>
<tr>
<td>%[width]s</td>
<td>读指定宽度的数据</td>
</tr>
<tr>
<td>%[a-z]</td>
<td>匹配a到z中任意字符(尽可能多的匹配)</td>
</tr>
<tr>
<td>%[aBc]</td>
<td>匹配a、B、c中一员，贪婪性</td>
</tr>
<tr>
<td><code>%[^a]</code></td>
<td>匹配非a的任意字符，贪婪性</td>
</tr>
<tr>
<td><code>%[^a-z]</code></td>
<td>表示读取除a-z以外的所有字符</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 跳过数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//跳过前面的数字</span></span><br><span class="line">	<span class="comment">//匹配第一个字符是否是数字，如果是，则跳过</span></span><br><span class="line">	<span class="comment">//如果不是则停止匹配</span></span><br><span class="line">	<span class="built_in">sscanf</span>(<span class="string">"123456aaaa"</span>, <span class="string">"%*d%s"</span>, buf); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 读取指定宽度数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//跳过前面的数字</span></span><br><span class="line">	<span class="built_in">sscanf</span>(<span class="string">"123456aaaa"</span>, <span class="string">"%7s"</span>, buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 匹配a-z中任意字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//跳过前面的数字</span></span><br><span class="line">  	<span class="comment">//先匹配第一个字符，判断字符是否是a-z中的字符，如果是匹配</span></span><br><span class="line">	<span class="comment">//如果不是停止匹配</span></span><br><span class="line">	<span class="built_in">sscanf</span>(<span class="string">"abcdefg123456"</span>, <span class="string">"%[a-z]"</span>, buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 匹配aBc中的任何一个</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//跳过前面的数字</span></span><br><span class="line">	<span class="comment">//先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配</span></span><br><span class="line">	<span class="built_in">sscanf</span>(<span class="string">"abcdefg123456"</span>, <span class="string">"%[aBc]"</span>, buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 匹配非a的任意字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//跳过前面的数字</span></span><br><span class="line">	<span class="comment">//先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配</span></span><br><span class="line">	<span class="built_in">sscanf</span>(<span class="string">"bcdefag123456"</span>, <span class="string">"%[^a]"</span>, buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 匹配非a-z中的任意字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//跳过前面的数字</span></span><br><span class="line">	<span class="comment">//先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配</span></span><br><span class="line">	<span class="built_in">sscanf</span>(<span class="string">"123456ABCDbcdefag"</span>, <span class="string">"%[^a-z]"</span>, buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"buf:%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6-1-一级指针易错点"><a href="#2-6-1-一级指针易错点" class="headerlink" title="2.6.1 一级指针易错点"></a>2.6.1 一级指针易错点</h4><ul>
<li><p>越界</p>
</li>
<li><p>指针叠加会不断改变指针指向 <code>p++</code></p>
</li>
<li><p>返回局部变量地址</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_str</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> str[] = <span class="string">"abcdedsgads"</span>; <span class="comment">//栈区，</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[get_str]str = %s\n"</span>, str);</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同一块内存释放多次<ul>
<li>free()函数的功能只是告诉系统 p 指向的内存可以回收了。就是说，p 指向的内存使用权交还给系统。但是，p的值还是原来的值(野指针)，p还是指向原来的内存</li>
</ul>
</li>
</ul>
<h3 id="2-7-const使用"><a href="#2-7-const使用" class="headerlink" title="2.7 const使用"></a>2.7 const使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const修饰变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//1. const基本概念</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//i = 100; //错误，只读变量初始化之后不能修改</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2. 定义const变量最好初始化</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> j;</span><br><span class="line">	<span class="comment">//j = 100; //错误，不能再次赋值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3. c语言的const是一个只读变量，并不是一个常量，可通过指针间接修改</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> k = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//k = 100; //错误，不可直接修改，我们可通过指针间接修改</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"k:%d\n"</span>, k);</span><br><span class="line">	<span class="keyword">int</span>* p = &amp;k;</span><br><span class="line">	*p = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"k:%d\n"</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const 修饰指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//const放在*号左侧 修饰p_a指针指向的内存空间不能修改,但可修改指针的指向</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>* p_a = &amp;a;</span><br><span class="line">	<span class="comment">//*p_a = 100; //不可修改指针指向的内存空间</span></span><br><span class="line">	p_a = &amp;b; <span class="comment">//可修改指针的指向</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//const放在*号的右侧， 修饰指针的指向不能修改，但是可修改指针指向的内存空间</span></span><br><span class="line">	<span class="keyword">int</span>* <span class="keyword">const</span> p_b = &amp;a;</span><br><span class="line">	<span class="comment">//p_b = &amp;b; //不可修改指针的指向</span></span><br><span class="line">	*p_b = <span class="number">100</span>; <span class="comment">//可修改指针指向的内存空间</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针的指向和指针指向的内存空间都不能修改</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p_c = &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//const指针用法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次都对对象进行拷贝，效率低，应该用指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPersonByValue</span><span class="params">(struct Person person)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Name:%s\n"</span>, person.name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person.id);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person.age);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person.score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是用指针会有副作用，可能会不小心修改原数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPersonByPointer</span><span class="params">(<span class="keyword">const</span> struct Person *person)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Name:%s\n"</span>, person-&gt;name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person-&gt;id);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person-&gt;age);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Name:%d\n"</span>, person-&gt;score);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p</span> = &#123;</span> <span class="string">"Obama"</span>, <span class="number">1101</span>, <span class="number">23</span>, <span class="number">87</span> &#125;;</span><br><span class="line">	<span class="comment">//printPersonByValue(p);</span></span><br><span class="line">	printPersonByPointer(&amp;p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、指针的指针-二级指针"><a href="#三、指针的指针-二级指针" class="headerlink" title="三、指针的指针(二级指针)"></a>三、指针的指针(二级指针)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> *b = &amp;a;</span><br><span class="line"><span class="keyword">int</span> **c = &amp;b;</span><br></pre></td></tr></table></figure>

<p>它在内存中的大概模样大致如下：</p>
<img src="/images/imageProgramC/二级指针.png">

<h3 id="3-1-二级指针做形参输出特性"><a href="#3-1-二级指针做形参输出特性" class="headerlink" title="3.1 二级指针做形参输出特性"></a>3.1 二级指针做形参输出特性</h3><p>二级指针做参数的输出特性是指由被调函数分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被调函数,由参数n确定分配多少个元素内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocate_space</span><span class="params">(<span class="keyword">int</span> **arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="comment">//堆上分配n个int类型元素内存</span></span><br><span class="line">	<span class="keyword">int</span> *temp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)* n);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == temp)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//给内存初始化值</span></span><br><span class="line">	<span class="keyword">int</span> *pTemp = temp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i ++)&#123;</span><br><span class="line">		<span class="comment">//temp[i] = i + 100;</span></span><br><span class="line">		*pTemp = i + <span class="number">100</span>;</span><br><span class="line">		pTemp++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//指针间接赋值</span></span><br><span class="line">	*arr = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i ++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二级指针输出特性(由被调函数分配内存)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *arr = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//给arr指针间接赋值</span></span><br><span class="line">	allocate_space(&amp;arr,n);</span><br><span class="line">	<span class="comment">//输出arr指向数组的内存</span></span><br><span class="line">	print_array(arr, n);</span><br><span class="line">	<span class="comment">//释放arr所指向内存空间的值</span></span><br><span class="line">	<span class="keyword">if</span> (arr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">free</span>(arr);</span><br><span class="line">		arr = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-二级指针做形参输入特性"><a href="#3-2-二级指针做形参输入特性" class="headerlink" title="3.2 二级指针做形参输入特性"></a>3.2 二级指针做形参输入特性</h3><p>二级指针做形参输入特性是指由主调函数分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> **arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i ++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,*(arr[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二级指针输入特性(由主调函数分配内存)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> a2 = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">int</span> a3 = <span class="number">30</span>;</span><br><span class="line">	<span class="keyword">int</span> a4 = <span class="number">40</span>;</span><br><span class="line">	<span class="keyword">int</span> a5 = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>** arr = (<span class="keyword">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *) * n);</span><br><span class="line">	arr[<span class="number">0</span>] = &amp;a1;</span><br><span class="line">	arr[<span class="number">1</span>] = &amp;a2;</span><br><span class="line">	arr[<span class="number">2</span>] = &amp;a3;</span><br><span class="line">	arr[<span class="number">3</span>] = &amp;a4;</span><br><span class="line">	arr[<span class="number">4</span>] = &amp;a5;</span><br><span class="line"></span><br><span class="line">	print_array(arr,n);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(arr);</span><br><span class="line">	arr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、位运算"><a href="#四、位运算" class="headerlink" title="四、位运算"></a>四、位运算</h2><h3 id="4-1-位逻辑运算符"><a href="#4-1-位逻辑运算符" class="headerlink" title="4.1 位逻辑运算符"></a>4.1 位逻辑运算符</h3><p>4个位运算符用于整型数据，包括char.将这些位运算符成为位运算的原因是它们对每位进行操作，而不影响左右两侧的位。请不要将这些运算符与常规的逻辑运算符(&amp;&amp; 、||和!)相混淆，常规的位的逻辑运算符对整个值进行操作。</p>
<ul>
<li><strong>按位取反~</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> a = <span class="number">2</span>;   <span class="comment">//00000010</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> b = ~a;  <span class="comment">//11111101</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ret = %d\n"</span>, a); <span class="comment">//ret = 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ret = %d\n"</span>, b); <span class="comment">//ret = 253</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>位与（AND）: &amp;</strong></p>
<ul>
<li>二进制运算符&amp;通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应位都是1时结果才为1。</li>
</ul>
</li>
<li><p><strong>位或（OR）: |</strong></p>
<ul>
<li>二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1.</li>
</ul>
</li>
<li><p><strong>位异或:</strong></p>
<ul>
<li>二进制运算符 <code>^</code> 对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0.</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10010011</span>) </span><br><span class="line">^ (<span class="number">00111101</span>)</span><br><span class="line">= (<span class="number">10101110</span>)</span><br></pre></td></tr></table></figure>

<p><strong>用法</strong>：</p>
<ul>
<li>打开位</li>
</ul>
<p>已知：10011010：</p>
<ol>
<li><p>将位2打开</p>
<p><code>flag | 10011010</code></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10011010</span>)</span><br><span class="line">| (<span class="number">00000100</span>)</span><br><span class="line">= (<span class="number">10011110</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>将所有位打开。</p>
<p><code>flag | ~flag</code></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10011010</span>)</span><br><span class="line">| (<span class="number">01100101</span>)</span><br><span class="line">= (<span class="number">11111111</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>关闭位</p>
<p><code>flag &amp; ~flag</code></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10011010</span>)</span><br><span class="line">&amp; (<span class="number">01100101</span>)</span><br><span class="line">= (<span class="number">00000000</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>转置位</p>
<ul>
<li>转置(toggling)一个位表示如果该位打开，则关闭该位；如果该位关闭，则打开。您可以使用位异或运算符来转置。其思想是如果b是一个位(1或0)，那么如果b为1则 <code>b^1</code> 为0，如果b为0，则 <code>1^b</code> 为1。无论b的值是0还是1, <code>0^b</code> 为b.</li>
</ul>
<p><code>flag ^ 0xff</code></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">10010011</span>)</span><br><span class="line">^ (<span class="number">11111111</span>)</span><br><span class="line">= (<span class="number">01101100</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>交换两个数不需要临时变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a ^ b = temp;</span></span><br><span class="line"><span class="comment">//a ^ temp = b;</span></span><br><span class="line"><span class="comment">//b ^ temp = a</span></span><br><span class="line">  (<span class="number">10010011</span>)</span><br><span class="line">^ (<span class="number">00100110</span>)</span><br><span class="line">= (<span class="number">10110101</span>)</span><br><span class="line"></span><br><span class="line">  (<span class="number">10110101</span>)</span><br><span class="line">^ (<span class="number">00100110</span>)</span><br><span class="line">   <span class="number">10010011</span></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = b ^ a;</span><br><span class="line">    a = a ^ b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d b = %d/n"</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-移位运算符"><a href="#4-2-移位运算符" class="headerlink" title="4.2 移位运算符"></a>4.2 移位运算符</h3><ul>
<li><p><strong>左移 &lt;&lt;</strong></p>
<ul>
<li><p>左移运算符 <code>&lt;&lt;</code> 将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。在下面例子中，每位向左移动两个位置。</p>
</li>
<li><p>左移一位相当于原值 <code>*2</code>.</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">10001010</span>) &lt;&lt; <span class="number">2</span></span><br><span class="line">(<span class="number">00101000</span>)</span><br><span class="line">    </span><br><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">1</span> = <span class="number">2</span>;</span><br><span class="line"><span class="number">2</span> &lt;&lt; <span class="number">1</span> = <span class="number">4</span>;</span><br><span class="line"><span class="number">4</span> &lt;&lt; <span class="number">1</span> = <span class="number">8</span>;</span><br><span class="line"><span class="number">8</span> &lt;&lt; <span class="number">2</span> = <span class="number">32</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>右移 &gt;&gt;</strong><ul>
<li>右移运算符 <code>&gt;&gt;</code> 将其左侧的操作数的值每位向右移动，移动的位数由其右侧的操作数指定。丢弃移出左侧操作数有段的位。对于unsigned类型，使用0填充左端空出的位。<strong>对于有符号类型，结果依赖于机器。空出的位可能用0填充，或者使用符号(最左端)位的副本填充</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有符号值</span></span><br><span class="line">(<span class="number">10001010</span>) &gt;&gt; <span class="number">2</span></span><br><span class="line">(<span class="number">00100010</span>)     <span class="comment">//在某些系统上的结果值</span></span><br><span class="line"></span><br><span class="line">(<span class="number">10001010</span>) &gt;&gt; <span class="number">2</span></span><br><span class="line">(<span class="number">11100010</span>)     <span class="comment">//在另一些系统上的解雇</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//无符号值</span></span><br><span class="line">(<span class="number">10001010</span>) &gt;&gt; <span class="number">2</span></span><br><span class="line">(<span class="number">00100010</span>)    <span class="comment">//所有系统上的结果值</span></span><br></pre></td></tr></table></figure>

<p><strong>用法：移位运算符</strong>：</p>
<ul>
<li>移位运算符能够提供快捷、高效（依赖于硬件）对2的幂的乘法和除法。</li>
</ul>
<table>
<thead>
<tr>
<th>number &lt;&lt; n</th>
<th>number乘以2的n次幂</th>
</tr>
</thead>
<tbody><tr>
<td>number &gt;&gt; n</td>
<td>如果number非负，则用number除以2的n次幂</td>
</tr>
</tbody></table>
<h2 id="五、多维数组"><a href="#五、多维数组" class="headerlink" title="五、多维数组"></a>五、多维数组</h2><h3 id="5-1-一维数组"><a href="#5-1-一维数组" class="headerlink" title="5.1 一维数组"></a>5.1 一维数组</h3><ul>
<li>元素类型角度：数组是相同类型的变量的有序集合</li>
<li>内存角度：连续的一大片内存空间</li>
</ul>
<p><strong>请问：指针和数组是等价的吗？</strong></p>
<p>答案是<strong>否定</strong>的。数组名在表达式中使用的时候，编译器才会产生一个指针常量。那么数组在什么情况下不能作为指针常量呢？在以下两种场景下：</p>
<ul>
<li>当数组名作为sizeof操作符的操作数的时候，此时sizeof返回的是整个数组的长度，而不是指针数组指针的长度。</li>
<li>当数组名作为&amp;操作符的操作数的时候，此时返回的是一个指向数组的指针，而不是指向某个数组元素的指针常量。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//arr = NULL; //arr作为指针常量，不可修改</span></span><br><span class="line"><span class="keyword">int</span> *p = arr; <span class="comment">//此时arr作为指针常量来使用</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(arr):%d\n"</span>, <span class="keyword">sizeof</span>(arr)); <span class="comment">//此时sizeof结果为整个数组的长度</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;arr type is %s\n"</span>, <span class="keyword">typeid</span>(&amp;arr).name()); <span class="comment">//int(*)[10]而不是int*</span></span><br></pre></td></tr></table></figure>

<p><strong>下标引用</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>*(arr + 3)</strong> ,这个表达式是什么意思呢？<ul>
<li>首先，我们说数组在表达式中是一个指向整型的指针，所以此表达式表示arr指针向后移动了3个元素的长度。然后通过间接访问操作符从这个新地址开始获取这个位置的值。这个和下标的引用的执行过程完全相同。所以如下表达式是等同的：</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(arr + <span class="number">3</span>)</span><br><span class="line">arr[<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p><strong>问题 1</strong>：数组下标可否为负值？</p>
<p><strong>问题 2</strong>：请阅读如下代码，说出结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> *p = arr + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p = %d\n"</span>, *p); 		<span class="comment">// 6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p = %d\n"</span>, p[<span class="number">-1</span>]);		<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h4 id="5-1-1-数组和指针"><a href="#5-1-1-数组和指针" class="headerlink" title="5.1.1 数组和指针"></a>5.1.1 数组和指针</h4><p>指针和数组并不是相等的。为了说明这个概念，请考虑下面两个声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *b;</span><br></pre></td></tr></table></figure>

<p>声明一个数组时，编译器根据声明所指定的元素数量为数组分配内存空间，然后再创建数组名，指向这段空间的起始位置。声明一个指针变量的时候，编译器只为指针本身分配内存空间，并不为任何整型值分配内存空间，指针并未初始化指向任何现有的内存空间。</p>
<p>因此，表达式 <code>*a</code> 是完全合法的，但是表达式 <code>*b</code> 却是非法的。<code>*b</code> 将访问内存中一个不确定的位置，将会导致程序终止。另一方面 b++ 可以通过编译，a++ 却不行，因为 a 是一个常量值。</p>
<h4 id="5-1-2-作为函数参数的数组名"><a href="#5-1-2-作为函数参数的数组名" class="headerlink" title="5.1.2 作为函数参数的数组名"></a>5.1.2 作为函数参数的数组名</h4><p>当一个数组名作为一个参数传递给一个函数的时候发生什么情况呢？我们现在知道数组名其实就是一个指向数组第1个元素的指针，所以很明白此时传递给函数的是一份指针的拷贝。所以函数的形参实际上是一个指针。但是为了使程序员新手容易上手一些，编译器也接受数组形式的函数形参。因此下面两种函数原型是相等的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> *arr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们可以使用任何一种声明，但哪一个更准确一些呢？答案是指针。因为实参实际上是个指针，而不是数组。<strong>同样sizeof arr值是指针的长度，而不是数组的长度</strong>。</p>
<p>现在我们清楚了，<strong>为什么一维数组中无须写明它的元素数目了，因为形参只是一个指针，并不需要为数组参数分配内存。另一方面，这种方式使得函数无法知道数组的长度。如果函数需要知道数组的长度，它必须显式传递一个长度参数给函数</strong>。</p>
<h3 id="5-2-多维数组"><a href="#5-2-多维数组" class="headerlink" title="5.2 多维数组"></a>5.2 多维数组</h3><p><strong>数组名</strong>：</p>
<ul>
<li>一维数组名的值是一个指针常量，它的类型是“指向元素类型的指针”，它指向数组的第1个元素。多维数组也是同理，多维数组的数组名也是指向第一个元素，只不过第一个元素是一个数组。例如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p>可以理解为这是一个一维数组，包含了3个元素，只是每个元素恰好是包含了10个元素的数组。arr就表示指向它的第1个元素的指针，所以arr是一个指向了包含了10个整型元素的数组的指针。</p>
<p><strong>指向数组的指针(数组指针)</strong>：</p>
<p>数组指针，它是指针，指向数组的指针。</p>
<p>数组的类型由<strong>元素类型</strong>和<strong>数组大小</strong>共同决定：int array[5]  的类型为  int[5]；C语言可通过typedef定义一个数组类型：</p>
<p>定义数组指针有一下三种方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先定义数组类型，再用数组类型定义数组指针</span></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">	<span class="comment">//有typedef是定义类型，没有则是定义变量,下面代码定义了一个数组类型ArrayType</span></span><br><span class="line">	typedef int(ArrayType)[10];</span><br><span class="line">	<span class="comment">//int ArrayType[10]; //定义一个数组，数组名为ArrayType</span></span><br><span class="line"></span><br><span class="line">	ArrayType myarr; <span class="comment">//等价于 int myarr[10];</span></span><br><span class="line">	ArrayType* pArr = &amp;arr; <span class="comment">//定义了一个数组指针pArr，并且指针指向数组arr</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,(*pArr)[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">	<span class="comment">//定义数组指针类型</span></span><br><span class="line">	typedef int(*ArrayType)[10];</span><br><span class="line">	ArrayType pArr = &amp;arr; <span class="comment">//定义了一个数组指针pArr，并且指针指向数组arr</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		(*pArr)[i] = i + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, (*pArr)[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">int</span>(*pArr)[<span class="number">10</span>] = &amp;arr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		(*pArr)[i] = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, (*pArr)[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-1-指针数组-元素为指针"><a href="#5-2-1-指针数组-元素为指针" class="headerlink" title="5.2.1 指针数组(元素为指针)"></a>5.2.1 指针数组(元素为指针)</h4><p><strong>栈区指针数组</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组做函数函数，退化为指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">array_sort</span><span class="params">(<span class="keyword">char</span>** arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt; i; j --)&#123;</span><br><span class="line">			<span class="comment">//比较两个字符串</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(arr[j<span class="number">-1</span>],arr[j]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">char</span>* temp = arr[j - <span class="number">1</span>];</span><br><span class="line">				arr[j - <span class="number">1</span>] = arr[j];</span><br><span class="line">				arr[j] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">array_print</span><span class="params">(<span class="keyword">char</span>** arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//主调函数分配内存</span></span><br><span class="line">	<span class="comment">//指针数组</span></span><br><span class="line">	<span class="keyword">char</span>* p[] = &#123; <span class="string">"bbb"</span>, <span class="string">"aaa"</span>, <span class="string">"ccc"</span>, <span class="string">"eee"</span>, <span class="string">"ddd"</span>&#125;;</span><br><span class="line">	<span class="comment">//char** p = &#123; "aaa", "bbb", "ccc", "ddd", "eee" &#125;; //错误</span></span><br><span class="line">	<span class="keyword">int</span> len = <span class="keyword">sizeof</span>(p) / <span class="keyword">sizeof</span>(<span class="keyword">char</span>*);</span><br><span class="line">	<span class="comment">//打印数组</span></span><br><span class="line">	array_print(p, len);</span><br><span class="line">	<span class="comment">//对字符串进行排序</span></span><br><span class="line">	array_sort(p, len);</span><br><span class="line">	<span class="comment">//打印数组</span></span><br><span class="line">	array_print(p, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>堆区指针数组</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配内存</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>** <span class="title">allocate_memory</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span>** temp = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * n);</span><br><span class="line">	<span class="keyword">if</span> (temp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//分别给每一个指针malloc分配内存</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">		temp[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)* <span class="number">30</span>);</span><br><span class="line">		<span class="built_in">sprintf</span>(temp[i], <span class="string">"%2d_hello world!"</span>, i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">array_print</span><span class="params">(<span class="keyword">char</span>** arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_memory</span><span class="params">(<span class="keyword">char</span>** buf,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (buf == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)&#123;</span><br><span class="line">		<span class="built_in">free</span>(buf[i]);</span><br><span class="line">		buf[i] = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">char</span>** p = allocate_memory(n);</span><br><span class="line">	<span class="comment">//打印数组</span></span><br><span class="line">	array_print(p, n);</span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	free_memory(p, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二维数组的线性存储特性式</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组的线性存储</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[][<span class="number">3</span>] = &#123;</span><br><span class="line">		&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">		&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">		&#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> arr2[][<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr2) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如何证明二维数组是线性的？</span></span><br><span class="line">	<span class="comment">//通过将数组首地址指针转成Int*类型，那么步长就变成了4，就可以遍历整个数组</span></span><br><span class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)arr;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, p[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	PrintArray((<span class="keyword">int</span>*)arr, len);</span><br><span class="line">	PrintArray((<span class="keyword">int</span>*)arr2, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二维数组的3种形式参数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维数组的第一种形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray01</span><span class="params">(<span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">3</span>])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"arr[%d][%d]:%d\n"</span>, i, j, arr[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组的第二种形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray02</span><span class="params">(<span class="keyword">int</span> arr[][<span class="number">3</span>])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"arr[%d][%d]:%d\n"</span>, i, j, arr[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组的第二种形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray03</span><span class="params">(<span class="keyword">int</span>(*arr)[<span class="number">3</span>])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"arr[%d][%d]:%d\n"</span>, i, j, arr[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[][<span class="number">3</span>] = &#123; </span><br><span class="line">		&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">		&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">		&#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	PrintArray01(arr);</span><br><span class="line">	PrintArray02(arr);</span><br><span class="line">	PrintArray03(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3 总结"></a>5.3 总结</h3><p><strong>编程提示</strong>：</p>
<ul>
<li>源代码的可读性几乎总是比程序的运行时效率更为重要</li>
<li><strong>只要有可能，函数的指针形参都应该声明为const</strong></li>
<li>在多维数组的初始值列表中使用完整的多层花括号提供可读性</li>
</ul>
<p><strong>内容总结</strong>：</p>
<ul>
<li>在绝大多数表达式中，数组名的值是指向数组第1个元素的指针。<strong>这个规则只有两个例外，sizeof和对数组名&amp;</strong>。</li>
<li>指针和数组并不相等。当我们声明一个数组的时候，同时也分配了内存。但是声明指针的时候，只分配容纳指针本身的空间。</li>
<li>当数组名作为函数参数时，实际传递给函数的是一个指向数组第1个元素的指针。</li>
<li>我们不单可以创建指向普通变量的指针，也可创建指向数组的指针。</li>
</ul>
<h2 id="六、结构体"><a href="#六、结构体" class="headerlink" title="六、结构体"></a>六、结构体</h2><h3 id="6-1-结构体基础知识"><a href="#6-1-结构体基础知识" class="headerlink" title="6.1 结构体基础知识"></a>6.1 结构体基础知识</h3><p>结构体类型的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PERSON</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;Person;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>定义结构体类型时不要直接给成员赋值，结构体只是一个类型，编译器还没有为其分配空间，只有根据其类型定义变量时，才分配空间，有空间后才能赋值。</p>
<p><strong>结构体变量的定义</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;p1; <span class="comment">//定义类型同时定义变量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;p2; <span class="comment">//定义类型同时定义变量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p3</span>;</span> <span class="comment">//通过类型直接定义</span></span><br></pre></td></tr></table></figure>

<p><strong>结构体成员的使用</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//在栈上分配空间</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br><span class="line">	<span class="built_in">strcpy</span>(p1.name, <span class="string">"John"</span>);</span><br><span class="line">	p1.age = <span class="number">30</span>;</span><br><span class="line">	<span class="comment">//如果是普通变量，通过点运算符操作结构体成员</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>, p1.name, p1.age);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在堆上分配空间</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Person</span>* <span class="title">p2</span> = (<span class="title">struct</span> <span class="title">Person</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Person</span>));</span></span><br><span class="line">	<span class="built_in">strcpy</span>(p2-&gt;name, <span class="string">"Obama"</span>);</span><br><span class="line">	p2-&gt;age = <span class="number">33</span>;</span><br><span class="line">	<span class="comment">//如果是指针变量，通过-&gt;操作结构体成员</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>, p2-&gt;name, p2-&gt;age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>深拷贝和浅拷贝</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个老师有N个学生</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TEACHER</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span>* name;</span><br><span class="line">&#125;Teacher;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Teacher t1;</span><br><span class="line">	t1.name = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(t1.name , <span class="string">"John"</span>);</span><br><span class="line"></span><br><span class="line">	Teacher t2;</span><br><span class="line">	t2 = t1;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对手动开辟的内存，需要手动拷贝</span></span><br><span class="line">	t2.name = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(t2.name, t1.name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (t1.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">free</span>(t1.name);</span><br><span class="line">		t1.name = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (t2.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">free</span>(t2.name);</span><br><span class="line">		t1.name = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结构体数组</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//在栈上分配空间</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>[3] = &#123;</span></span><br><span class="line">		&#123; <span class="string">"John"</span>, <span class="number">30</span> &#125;,</span><br><span class="line">		&#123; <span class="string">"Obama"</span>, <span class="number">33</span> &#125;,</span><br><span class="line">		&#123; <span class="string">"Edward"</span>, <span class="number">25</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p2</span>[3] = &#123;</span> <span class="string">"John"</span>, <span class="number">30</span>, <span class="string">"Obama"</span>, <span class="number">33</span>, <span class="string">"Edward"</span>, <span class="number">25</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>;i ++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>,p1[i].name,p1[i].age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"-----------------\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>, p2[i].name, p2[i].age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"-----------------\n"</span>);</span><br><span class="line">	<span class="comment">//在堆上分配结构体数组</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Person</span>* <span class="title">p3</span> = (<span class="title">struct</span> <span class="title">Person</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Person</span>) * 3);</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(p3[i].name, <span class="string">"Name_%d"</span>, i + <span class="number">1</span>);</span><br><span class="line">		p3[i].age = <span class="number">20</span> + i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>, p3[i].name, p3[i].age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-结构体嵌套指针"><a href="#6-2-结构体嵌套指针" class="headerlink" title="6.2 结构体嵌套指针"></a>6.2 结构体嵌套指针</h3><p><strong>结构体嵌套一级指针</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span>* name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocate_memory</span><span class="params">(struct Person** person)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (person == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Person</span>* <span class="title">temp</span> = (<span class="title">struct</span> <span class="title">Person</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Person</span>));</span></span><br><span class="line">	<span class="keyword">if</span> (temp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//给name指针分配内存</span></span><br><span class="line">	temp-&gt;name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)* <span class="number">64</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(temp-&gt;name, <span class="string">"John"</span>);</span><br><span class="line">	temp-&gt;age = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	*person = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_person</span><span class="params">(struct Person* person)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Name:%s Age:%d\n"</span>,person-&gt;name,person-&gt;age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_memory</span><span class="params">(struct Person** person)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (person == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Person</span>* <span class="title">temp</span> = *<span class="title">person</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (temp-&gt;name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">free</span>(temp-&gt;name);</span><br><span class="line">		temp-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Person</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	allocate_memory(&amp;p);</span><br><span class="line">	print_person(p);</span><br><span class="line">	free_memory(&amp;p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结构体嵌套二级指针</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个老师有N个学生</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TEACHER</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">char</span>** students;</span><br><span class="line">&#125;Teacher;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_teacher</span><span class="params">(Teacher** teacher,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (teacher == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建老师数组</span></span><br><span class="line">	Teacher* teachers = (Teacher*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Teacher)* n);</span><br><span class="line">	<span class="keyword">if</span> (teachers == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//给每一个老师分配学生</span></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(teachers[i].name, <span class="string">"老师_%d"</span>, i + <span class="number">1</span>);</span><br><span class="line">		teachers[i].students = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * m);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m;j++)&#123;</span><br><span class="line">			teachers[i].students[j] = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line">			<span class="built_in">sprintf</span>(teachers[i].students[j], <span class="string">"学生_%d"</span>, num + <span class="number">1</span>);</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	*teacher = teachers;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_teacher</span><span class="params">(Teacher* teacher,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s:\n"</span>, teacher[i].name);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m;j++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"  %s"</span>,teacher[i].students[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_memory</span><span class="params">(Teacher** teacher,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (teacher == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Teacher* temp = *teacher;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m;j ++)&#123;</span><br><span class="line">			<span class="built_in">free</span>(temp[i].students[j]);</span><br><span class="line">			temp[i].students[j] = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(temp[i].students);</span><br><span class="line">		temp[i].students = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Teacher* p = <span class="literal">NULL</span>;</span><br><span class="line">	create_teacher(&amp;p,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">	print_teacher(p, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	free_memory(&amp;p,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-结构体成员偏移量"><a href="#6-3-结构体成员偏移量" class="headerlink" title="6.3 结构体成员偏移量"></a>6.3 结构体成员偏移量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一旦结构体定义下来，则结构体中的成员内存布局就定下了</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> a;  </span><br><span class="line">	<span class="keyword">int</span> b;      </span><br><span class="line">	<span class="keyword">int</span> c;        </span><br><span class="line"></span><br><span class="line">&#125; Teacher;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Teacher  t1;</span><br><span class="line">	Teacher*p = <span class="literal">NULL</span>;</span><br><span class="line">	p = &amp;t1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> offsize1 = (<span class="keyword">int</span>)&amp;(p-&gt;b) - (<span class="keyword">int</span>)p;  <span class="comment">//age 相对于结构体 Teacher的偏移量</span></span><br><span class="line">	<span class="keyword">int</span> offsize2 = (<span class="keyword">int</span>)&amp;(((Teacher *)<span class="number">0</span>)-&gt;b);<span class="comment">//绝对0地址 age的偏移量</span></span><br><span class="line">	<span class="keyword">int</span> offsize3 = offsetof(Teacher, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"offsize1:%d \n"</span>, offsize1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"offsize2:%d \n"</span>, offsize2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"offsize3:%d \n"</span>, offsize3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-结构体字节对齐"><a href="#6-4-结构体字节对齐" class="headerlink" title="6.4 结构体字节对齐"></a>6.4 结构体字节对齐</h3><p>在用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题。</p>
<p>从理论上讲，对于任何变量的访问都可以从任何地址开始访问，但是事实上不是如此，实际上访问特定类型的变量只能在特定的地址访问，这就需要各个变量在空间上按一定的规则排列， 而不是简单地顺序排列，这就是<strong>内存对齐</strong>。</p>
<h4 id="6-4-1-内存对齐原因"><a href="#6-4-1-内存对齐原因" class="headerlink" title="6.4.1 内存对齐原因"></a>6.4.1 内存对齐原因</h4><p>我们知道内存的最小单元是一个字节，当cpu从内存中读取数据的时候，是一个一个字节读取，但是实际上cpu将内存当成多个块，每次从内存中读取一个块，这个块的大小可能是2、4、8、16等</p>
<p>内存对齐是操作系统为了提高访问内存的策略。操作系统在访问内存的时候，每次读取一定长度(这个长度是操作系统默认的对齐数，或者默认对齐数的整数倍)。如果没有对齐，为了访问一个变量可能产生二次访问。</p>
<p><strong>为什么要简单内存对齐？</strong></p>
<ul>
<li>提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要2个读取周期读取该变量。</li>
<li>某些平台只能在特定的地址处访问特定类型的数据，否则抛出硬件异常给操作系统。</li>
</ul>
<h4 id="6-4-2-如何内存对齐"><a href="#6-4-2-如何内存对齐" class="headerlink" title="6.4.2 如何内存对齐"></a>6.4.2 如何内存对齐</h4><ul>
<li>对于标准数据类型，它的地址只要是它的长度的整数倍。</li>
<li>对于非标准数据类型，比如结构体，要遵循一下对齐原则：<ul>
<li>数组成员对齐规则。第一个数组成员应该放在offset为0的地方，以后每个数组成员应该放在offset为<strong>min（当前成员的大小，#pargama pack(n)）</strong>整数倍的地方开始（比如int在32位机器为４字节，#pargama pack(2)，那么从2的倍数地方开始存储）。</li>
<li>结构体总的大小，也就是sizeof的结果，必须是<strong>min（结构体内部最大成员，#pargama pack(n)）</strong>的整数倍，不足要补齐。</li>
<li>结构体做为成员的对齐规则。如果一个结构体B里嵌套另一个结构体A,还是以最大成员类型的大小对齐，但是结构体A的起点为A内部最大成员的整数倍的地方。（struct B里存有struct A，A里有char，int，double等成员，那A应该从8的整数倍开始存储。），结构体A中的成员的对齐规则仍满足原则1、原则2。</li>
</ul>
</li>
</ul>
<p>手动设置对齐模数:</p>
<ul>
<li><strong>#pragma pack(show)</strong><ul>
<li>显示当前packing alignment的字节数，以warning message的形式被显示。</li>
</ul>
</li>
<li><strong>#pragma pack(push)</strong> <ul>
<li>将当前指定的packing alignment数组进行压栈操作，这里的栈是the internal compiler stack,同事设置当前的packing alignment为n；如果n没有指定，则将当前的packing alignment数组压栈。</li>
</ul>
</li>
<li><strong>#pragma pack(pop)</strong> <ul>
<li>从internal compiler stack中删除最顶端的reaord; 如果没有指定n,则当前栈顶record即为新的packing alignement数值；如果指定了n，则n成为新的packing alignment值</li>
</ul>
</li>
<li><strong>#pragma pack(n)</strong><ul>
<li>指定packing的数值，以字节为单位，缺省数值是8，合法的数值分别是1,2,4,8,16。 </li>
</ul>
</li>
</ul>
<p>内存对齐案例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STUDENT</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">char</span> b;</span><br><span class="line">	<span class="keyword">double</span> c;</span><br><span class="line">	<span class="keyword">float</span> d;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STUDENT2</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	Student b; </span><br><span class="line">	<span class="keyword">double</span> c;</span><br><span class="line">&#125;Student2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//Student</span></span><br><span class="line">	<span class="comment">//a从偏移量0位置开始存储</span></span><br><span class="line">	<span class="comment">//b从4位置开始存储</span></span><br><span class="line">	<span class="comment">//c从8位置开始存储</span></span><br><span class="line">	<span class="comment">//d从12位置开存储</span></span><br><span class="line">	<span class="comment">//所以Student内部对齐之后的大小为20 ，整体对齐，整体为最大类型的整数倍 也就是8的整数倍 为24</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sizeof Student:%d\n"</span>,<span class="keyword">sizeof</span>(Student));</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//Student2 </span></span><br><span class="line">	<span class="comment">//a从偏移量为0位置开始 8</span></span><br><span class="line">	<span class="comment">//b从偏移量为Student内部最大成员整数倍开始，也就是8开始 24</span></span><br><span class="line">	<span class="comment">//c从8的整数倍地方开始,也就是32开始</span></span><br><span class="line">	<span class="comment">//所以结构体Sutdnet2内部对齐之后的大小为：40 ， 由于结构体中最大成员为8，必须为8的整数倍 所以大小为40</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sizeof Student2:%d\n"</span>, <span class="keyword">sizeof</span>(Student2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、文件操作"><a href="#七、文件操作" class="headerlink" title="七、文件操作"></a>七、文件操作</h2><p>文件在今天的计算机系统中作用是很重要的。文件用来存放程序、文档、数据、表格、图片和其他很多种类的信息。作为一名程序员，您必须编程来创建、写入和读取文件。编写程序从文件读取信息或者将结果写入文件是一种经常性的需求。C提供了强大的和文件进行通信的方法。使用这种方法我们可以在程序中打开文件，然后使用专门的I/O函数读取文件或者写入文件。</p>
<p><strong>文件的概念</strong></p>
<ul>
<li>一个文件通常就是磁盘上一段命名的存储区。但是对于操作系统来说，文件就会更复杂一些。例如，一个大文件可以存储在一些分散的区段中，或者还会包含一些操作系统可以确定其文件类型的附加数据，但是这些是操作系统，而不是我们程序员所要关心的事情。我们应该考虑如何在C程序中处理文件。</li>
</ul>
<p><strong>流的概念</strong></p>
<p>流是一个动态的概念，可以将一个字节形象地比喻成一滴水，字节在设备、文件和程序之间的传输就是流，类似于水在管道中的传输，可以看出，流是对输入输出源的一种抽象，也是对传输信息的一种抽象。</p>
<p>C语言中，I/O操作可以简单地看作是从程序移进或移出字节，这种搬运的过程便称为流(stream)。程序只需要关心是否正确地输出了字节数据，以及是否正确地输入了要读取字节数据，特定I/O设备的细节对程序员是隐藏的。</p>
<p><strong>文本流</strong></p>
<ul>
<li>文本流，也就是我们常说的以文本模式读取文件。文本流的有些特性在不同的系统中可能不同。其中之一就是文本行的最大长度。标准规定至少允许254个字符。另一个可能不同的特性是文本行的结束方式。例如在Windows系统中，文本文件约定以一个回车符和一个换行符结尾。但是在Linux下只使用一个换行符结尾。</li>
<li>标准C把文本定义为零个或者多个字符，后面跟一个表示结束的换行符(\n).对于那些文本行的外在表现形式与这个定义不同的系统上，库函数负责外部形式和内部形式之间的翻译。例如，在Windows系统中，在输出时，文本的换行符被写成一对回车/换行符。在输入时，文本中的回车符被丢弃。这种不必考虑文本的外部形势而操纵文本的能力简化了可移植程序的创建。</li>
</ul>
<p><strong>二进制流</strong></p>
<ul>
<li>二进制流中的字节将完全根据程序编写它们的形式写入到文件中，而且完全根据它们从文件或设备读取的形式读入到程序中。它们并未做任何改变。这种类型的流适用于非文本数据，但是如果你不希望I/O函数修改文本文件的行末字符，也可以把它们用于文本文件。</li>
</ul>
<p>c语言在处理这两种文件的时候并不区分，都看成是字符流，按字节进行处理。</p>
<p><strong>我们程序中，经常看到的文本方式打开文件和二进制方式打开文件仅仅体现在换行符的处理上</strong>。</p>
<p>比如说，在widows下，文件的换行符是 <code>\r\n</code>，而在Linux下换行符则是 <code>\n</code>.</p>
<p>当对文件使用文本方式打开的时候，读写的windows文件中的换行符\r\n会被替换成\n读到内存中，当在windows下写入文件的时候，\n被替换成\r\n再写入文件。如果使用二进制方式打开文件，则不进行\r\n和\n之间的转换。 那么由于Linux下的换行符就是\n, 所以文本文件方式和二进制方式无区别。</p>
<h3 id="7-1-文件的操作"><a href="#7-1-文件的操作" class="headerlink" title="7.1 文件的操作"></a>7.1 文件的操作</h3><p><strong>文件流总览</strong></p>
<p>标准库函数是的我们在C程序中执行与文件相关的I/O任务非常方便。下面是关于文件I/O的一般概况。</p>
<ul>
<li>程序为同时处于活动状态的每个文件声明一个指针变量，其类型为 <code>FILE*</code>。这个指针指向这个FILE结构，当它处于活动状态时由流使用。</li>
<li>流通过fopen函数打开。为了打开一个流，我们必须指定需要访问的文件或设备以及他们的访问方式(读、写、或者读写)。Fopen和操作系统验证文件或者设备是否存在并初始化FILE。</li>
<li>根据需要对文件进行读写操作。</li>
<li>最后调用fclose函数关闭流。关闭一个流可以防止与它相关的文件被再次访问，保证任何存储于缓冲区中的数据被正确写入到文件中，并且释放FILE结构。</li>
</ul>
<p>标准I/O更为简单，因为它们并不需要打开或者关闭。</p>
<p>I/O函数以三种基本的形式处理数据：<strong>单个字符</strong>、<strong>文本行</strong>和<strong>二进制数据</strong>。对于每种形式都有一组特定的函数对它们进行处理。</p>
<p><strong>输入/输出函数家族</strong></p>
<table>
<thead>
<tr>
<th>家族名</th>
<th>目的</th>
<th>可用于所有流</th>
<th>只用于stdin和stdout</th>
</tr>
</thead>
<tbody><tr>
<td>getchar</td>
<td>字符输入</td>
<td>fgetc、getc</td>
<td>getchar</td>
</tr>
<tr>
<td>putchar</td>
<td>字符输出</td>
<td>fputc、putc</td>
<td>putchar</td>
</tr>
<tr>
<td>gets</td>
<td>文本行输入</td>
<td>fgets</td>
<td>gets</td>
</tr>
<tr>
<td>puts</td>
<td>文本行输出</td>
<td>fputs</td>
<td>puts</td>
</tr>
<tr>
<td>scanf</td>
<td>格式化输入</td>
<td>fscanf</td>
<td>scanf</td>
</tr>
<tr>
<td>printf</td>
<td>格式化输出</td>
<td>fprintf</td>
<td>printf</td>
</tr>
</tbody></table>
<h3 id="7-2-文件打开关闭"><a href="#7-2-文件打开关闭" class="headerlink" title="7.2 文件打开关闭"></a>7.2 文件打开关闭</h3><p>文件的打开操作表示将给用户指定的文件在内存分配一个FILE结构区，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。当使用打开函数时，必须给出文件名、文件操作方式(读、写或读写)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE * <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename, <span class="keyword">const</span> <span class="keyword">char</span> * mode)</span></span>;</span><br><span class="line">功能：打开文件</span><br><span class="line">参数：</span><br><span class="line">	filename：需要打开的文件名，根据需要加上路径</span><br><span class="line">	mode：打开文件的权限设置</span><br><span class="line">返回值：</span><br><span class="line">	成功：文件指针</span><br><span class="line">	失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>“r”</td>
<td>打开，只读，文件必须已经存在。</td>
</tr>
<tr>
<td>“w”</td>
<td>只写,如果文件不存在则创建,如果文件已存在则把文件长度截断(Truncate)为0字节。再重新写,也就是替换掉原来的文件内容文件指针指到头。</td>
</tr>
<tr>
<td>“a”</td>
<td>只能在文件末尾追加数据,如果文件不存在则创建</td>
</tr>
<tr>
<td>“rb”</td>
<td>打开一个二进制文件，只读</td>
</tr>
<tr>
<td>“wb”</td>
<td>打开一个二进制文件，只写</td>
</tr>
<tr>
<td>“ab”</td>
<td>打开一个二进制文件，追加</td>
</tr>
<tr>
<td>“r+”</td>
<td>允许读和写,文件必须已存在</td>
</tr>
<tr>
<td>“w+”</td>
<td>允许读和写,如果文件不存在则创建,如果文件已存在则把文件长度截断为0字节再重新写 。</td>
</tr>
<tr>
<td>“a+”</td>
<td>允许读和追加数据,如果文件不存在则创建</td>
</tr>
<tr>
<td>“rb+”</td>
<td>以读/写方式打开一个二进制文件</td>
</tr>
<tr>
<td>“wb+”</td>
<td>以读/写方式建立一个新的二进制文件</td>
</tr>
<tr>
<td>“ab+”</td>
<td>以读/写方式打开一个二进制文件进行追加</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// "\\"这样的路径形式，只能在windows使用</span></span><br><span class="line">	<span class="comment">// "/"这样的路径形式，windows和linux平台下都可用，建议使用这种</span></span><br><span class="line">	<span class="comment">// 路径可以是相对路径，也可是绝对路径</span></span><br><span class="line">	fp = fopen(<span class="string">"../test"</span>, <span class="string">"w"</span>);</span><br><span class="line">	<span class="comment">//fp = fopen("..\\test", "w");</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>) <span class="comment">//返回空，说明打开失败</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//perror()是标准出错打印函数，能打印调用库函数出错原因</span></span><br><span class="line">		perror(<span class="string">"open"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：应该检查fopen的返回值!如何函数失败，它会返回一个NULL值。如果程序不检查错误，这个NULL指针就会传给后续的I/O函数。它们将对这个指针执行间接访问，并将失败.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE * stream)</span></span>;</span><br><span class="line">功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。</span><br><span class="line">参数：</span><br><span class="line">	stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">	成功：<span class="number">0</span></span><br><span class="line">	失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>它表示该函数将关闭FILE指针对应的文件，并返回一个整数值。若成功地关闭了文件，则返回一个0值，否则返回一个非0值.</p>
<p><strong>文件读写函数回顾</strong></p>
<ul>
<li>按照字符读写文件：fgetc(), fputc()</li>
<li>按照行读写文件：fputs(), fgets()</li>
<li>按照块读写文件：fread(), fwirte()</li>
<li>按照格式化读写文件：fprintf(), fscanf()</li>
<li>按照随机位置读写文件：fseek(), ftell(), rewind()    </li>
</ul>
<p><strong>块读写函数回顾</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br><span class="line">功能：以数据块的方式给文件写入内容</span><br><span class="line">参数：</span><br><span class="line">	ptr：准备写入文件数据的地址</span><br><span class="line">	size： <span class="keyword">size_t</span> 为 <span class="keyword">unsigned</span> <span class="keyword">int</span>类型，此参数指定写入文件内容的块数据大小</span><br><span class="line">	nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb</span><br><span class="line">	stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">	成功：实际成功写入文件数据的块数，此值和nmemb相等</span><br><span class="line">	失败：<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br><span class="line">功能：以数据块的方式从文件中读取内容</span><br><span class="line">参数：</span><br><span class="line">	ptr：存放读取出来数据的内存空间</span><br><span class="line">	size： <span class="keyword">size_t</span> 为 <span class="keyword">unsigned</span> <span class="keyword">int</span>类型，此参数指定读取文件内容的块数据大小</span><br><span class="line">	nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb</span><br><span class="line">	stream：已经打开的文件指针</span><br><span class="line">返回值：</span><br><span class="line">	成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于<span class="number">0</span>，说明读到文件的结尾。</span><br><span class="line">	失败：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>格式化读写函数回顾</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE * stream, <span class="keyword">const</span> <span class="keyword">char</span> * format, ...)</span></span>;</span><br><span class="line">功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 <span class="string">'\0'</span>  为止。</span><br><span class="line">参数：</span><br><span class="line">	stream：已经打开的文件</span><br><span class="line">	format：字符串格式，用法和<span class="built_in">printf</span>()一样</span><br><span class="line">返回值：</span><br><span class="line">	成功：实际写入文件的字符个数</span><br><span class="line">	失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE * stream, <span class="keyword">const</span> <span class="keyword">char</span> * format, ...)</span></span>;</span><br><span class="line">功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。</span><br><span class="line">参数：</span><br><span class="line">	stream：已经打开的文件</span><br><span class="line">	format：字符串格式，用法和<span class="built_in">scanf</span>()一样</span><br><span class="line">返回值：</span><br><span class="line">	成功：实际从文件中读取的字符个数</span><br><span class="line">	失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<strong>fscanf遇到空格和换行时结束。</strong></p>
<h3 id="7-3-读写配置文件"><a href="#7-3-读写配置文件" class="headerlink" title="7.3 读写配置文件"></a>7.3 读写配置文件</h3><img src="/images/imageProgramC/文件读写案例.png">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> key[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">char</span> val[<span class="number">128</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config</span>&#123;</span></span><br><span class="line">	FILE *fp; <span class="comment">//保存文件指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">info</span> *<span class="title">list</span>;</span> <span class="comment">//保存配置信息</span></span><br><span class="line">	<span class="keyword">int</span> lines; <span class="comment">//配置信息条数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载配置文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">load_file</span><span class="params">(<span class="keyword">char</span> *path, struct config **myconfig)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == path)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//以读写的方式打开文件</span></span><br><span class="line">	FILE *fp = fopen(path, <span class="string">"r+"</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> ==fp)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"文件打开失败!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//配置文件信息分配内存</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">config</span> *<span class="title">conf</span> = (<span class="title">struct</span> <span class="title">config</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">config</span>));</span></span><br><span class="line">	conf-&gt;fp = fp;</span><br><span class="line">	conf-&gt;<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针的间接赋值</span></span><br><span class="line">	*myconfig = conf;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计文件行数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_file</span><span class="params">(struct config *config)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == config)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> lines = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (fgets(buf, <span class="number">1024</span>, config-&gt;fp))&#123;</span><br><span class="line">		<span class="comment">//如果是注释则不统计</span></span><br><span class="line">		<span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">'#'</span>)&#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">		lines++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将文件指针重置到开始位置</span></span><br><span class="line">	fseek(config-&gt;fp,<span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> lines;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析配置文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parse_file</span><span class="params">(struct config *config)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == config)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获得配置文件行数</span></span><br><span class="line">	config-&gt;lines = count_file(config);</span><br><span class="line">	<span class="comment">//给每一行配置信息分配内存</span></span><br><span class="line">	config-&gt;<span class="built_in">list</span> = (struct info *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct info) * config-&gt;lines);</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (fgets(buf, <span class="number">1024</span>, config-&gt;fp))&#123;</span><br><span class="line">		<span class="comment">//去除每一行最后的\n字符</span></span><br><span class="line">		buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">		<span class="comment">//如果是注释则不显示</span></span><br><span class="line">		<span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">'#'</span>)&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(config-&gt;<span class="built_in">list</span>[index].key, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">		<span class="built_in">memset</span>(config-&gt;<span class="built_in">list</span>[index].val, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">char</span> *delimit = <span class="built_in">strchr</span>(buf, <span class="string">':'</span>);</span><br><span class="line">		<span class="built_in">strncpy</span>(config-&gt;<span class="built_in">list</span>[index].key, buf, delimit - buf);</span><br><span class="line">		<span class="built_in">strncpy</span>(config-&gt;<span class="built_in">list</span>[index].val, delimit + <span class="number">1</span>, <span class="built_in">strlen</span>(delimit + <span class="number">1</span>));</span><br><span class="line">		<span class="built_in">memset</span>(buf, <span class="number">0</span> , <span class="number">1024</span>);</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">get_file</span><span class="params">(struct config *config, <span class="keyword">char</span> *key)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == config)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == key)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; config-&gt;lines;i ++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(config-&gt;<span class="built_in">list</span>[i].key,key) == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> config-&gt;<span class="built_in">list</span>[i].val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_file</span><span class="params">(struct config *config)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == config)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭文件指针</span></span><br><span class="line">	fclose(config-&gt;fp);</span><br><span class="line">	config-&gt;fp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//释放配置信息</span></span><br><span class="line">	<span class="built_in">free</span>(config-&gt;<span class="built_in">list</span>);</span><br><span class="line">	config-&gt;<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">free</span>(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *path = <span class="string">"./my.ini"</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">config</span> *<span class="title">conf</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	load_file(path, &amp;conf);</span><br><span class="line">	parse_file(conf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"username"</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"password"</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"server_ip"</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"server_port"</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, get_file(conf, <span class="string">"aaaa"</span>));</span><br><span class="line">	destroy_file(conf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、链表"><a href="#八、链表" class="headerlink" title="八、链表"></a>八、链表</h2><h3 id="8-1-链表基本概念"><a href="#8-1-链表基本概念" class="headerlink" title="8.1 链表基本概念"></a>8.1 链表基本概念</h3><img src="/images/imageProgramC/链表.png">

<ul>
<li>链表是一种常用的数据结构，它通过指针将一些列数据结点，连接成一个数据链。相对于数组，链表具有更好的动态性（<strong>非顺序存储</strong>）。</li>
<li>数据域用来存储数据，指针域用于建立与下一个结点的联系。</li>
<li>建立链表时无需预先知道数据总量的，可以随机的分配空间，可以高效的在链表中的任意位置实时插入或删除数据。</li>
<li><strong>链表的开销，主要是访问顺序性和组织链的空间损失</strong>。</li>
</ul>
<p><strong>数组和链表的区别</strong>：</p>
<ul>
<li><p>数组：一次性分配一块连续的存储区域。</p>
<p>优点：随机访问元素效率高</p>
<p>缺点：</p>
<ul>
<li>需要分配一块连续的存储区域（很大区域，有可能分配失败）</li>
<li>删除和插入某个元素效率低</li>
</ul>
</li>
<li><p>链表：无需一次性分配一块连续的存储区域，只需分配n块节点存储区域，通过指针建立关系。</p>
<p>优点：</p>
<ul>
<li>不需要一块连续的存储区域</li>
<li>删除和插入某个元素效率高</li>
</ul>
<p>缺点：随机访问元素效率低</p>
</li>
</ul>
<h4 id="8-1-1-有关结构体的自身引用"><a href="#8-1-1-有关结构体的自身引用" class="headerlink" title="8.1.1 有关结构体的自身引用"></a>8.1.1 有关结构体的自身引用</h4><p>问题1：请问结构体可以嵌套本类型的结构体变量吗？</p>
<p>问题2：请问结构体可以嵌套本类型的结构体指针变量吗？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STUDENT</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TEACHER</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">	Student stu; <span class="comment">//结构体可以嵌套其他类型的结构体</span></span><br><span class="line">	<span class="comment">//Teacher stu;</span></span><br><span class="line">	<span class="comment">//struct _TEACHER teacher; //此时Teacher类型的成员还没有确定，编译器无法分配内存</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">TEACHER</span>* <span class="title">teacher</span>;</span> <span class="comment">//不论什么类型的指针，都只占4个字节，编译器可确定内存分配</span></span><br><span class="line">&#125;Teacher;</span><br></pre></td></tr></table></figure>

<ul>
<li>结构体可以嵌套另外一个结构体的任何类型变量;</li>
<li><strong>结构体嵌套本结构体普通变量（不可以）</strong>。本结构体的类型大小无法确定，类型本质：固定大小内存块别名;</li>
<li><strong>结构体嵌套本结构体指针变量（可以）</strong>, 指针变量的空间能确定，32位， 4字节， 64位， 8字节;</li>
</ul>
<h4 id="8-1-2-链表节点"><a href="#8-1-2-链表节点" class="headerlink" title="8.1.2 链表节点"></a>8.1.2 <strong>链表节点</strong></h4><p>大家思考一下，我们说链表是由一系列的节点组成，那么如何表示一个包含了数据域和指针域的节点呢？</p>
<p><strong>链表的节点类型实际上是结构体变量，此结构体包含数据域和指针域</strong>：</p>
<ul>
<li><p>数据域用来存储数据；</p>
</li>
<li><p>指针域用于建立与下一个结点的联系，<strong>当此节点为尾节点时，指针域的值为NULL</strong>；</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//数据域</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>       </span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure>

<img src="/images/imageProgramC/链表-01.png">

<h4 id="8-1-3-链表的分类"><a href="#8-1-3-链表的分类" class="headerlink" title="8.1.3 链表的分类"></a>8.1.3 链表的分类</h4><p>链表分为：</p>
<ul>
<li>静态链表</li>
<li>动态链表</li>
</ul>
<p>静态链表和动态链表是线性表链式存储结构的两种不同的表示方式：</p>
<ul>
<li><p>所有结点都是在程序中定义的，不是临时开辟的，也不能用完后释放，这种链表称为“静态链表”。</p>
</li>
<li><p>所谓动态链表，是指在程序执行过程中从无到有地建立起一个链表，即一个一个地开辟结点和输入各结点数据，并建立起前后相链的关系。</p>
</li>
</ul>
<p><strong>静态链表</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;	<span class="comment">//数据域</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//初始化三个结构体变量</span></span><br><span class="line">	Stu s1 = &#123; <span class="number">1</span>, <span class="string">"yuri"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">	Stu s2 = &#123; <span class="number">2</span>, <span class="string">"lily"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">	Stu s3 = &#123; <span class="number">3</span>, <span class="string">"lilei"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">	s1.next = &amp;s2; <span class="comment">//s1的next指针指向s2</span></span><br><span class="line">	s2.next = &amp;s3;</span><br><span class="line">	s3.next = <span class="literal">NULL</span>; <span class="comment">//尾结点</span></span><br><span class="line"></span><br><span class="line">	Stu *p = &amp;s1;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"id = %d, name = %s\n"</span>, p-&gt;id, p-&gt;name);</span><br><span class="line">		<span class="comment">//结点往后移动一位</span></span><br><span class="line">		p = p-&gt;next; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态链表</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;	<span class="comment">//数据域</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//动态分配3个节点</span></span><br><span class="line">	Stu *s1 = (Stu *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stu));</span><br><span class="line">	s1-&gt;id = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(s1-&gt;name, <span class="string">"yuri"</span>);</span><br><span class="line"></span><br><span class="line">	Stu *s2 = (Stu *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stu));</span><br><span class="line">	s2-&gt;id = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(s2-&gt;name, <span class="string">"lily"</span>);</span><br><span class="line"></span><br><span class="line">	Stu *s3 = (Stu *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stu));</span><br><span class="line">	s3-&gt;id = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(s3-&gt;name, <span class="string">"lilei"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//建立节点的关系</span></span><br><span class="line">	s1-&gt;next = s2; <span class="comment">//s1的next指针指向s2</span></span><br><span class="line">	s2-&gt;next = s3;</span><br><span class="line">	s3-&gt;next = <span class="literal">NULL</span>; <span class="comment">//尾结点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历节点</span></span><br><span class="line">	Stu *p = s1;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"id = %d, name = %s\n"</span>, p-&gt;id, p-&gt;name);</span><br><span class="line">		<span class="comment">//结点往后移动一位</span></span><br><span class="line">		p = p-&gt;next; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放节点空间</span></span><br><span class="line">	p = s1;</span><br><span class="line">	Stu *tmp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp = p;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">free</span>(tmp);</span><br><span class="line">		tmp = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>带头和不带头链表</strong></p>
<ul>
<li>带头链表：固定一个节点作为头结点(数据域不保存有效数据)，起一个标志位的作用，以后不管链表节点如何改变，此头结点固定不变。</li>
</ul>
<img src="/images/imageProgramC/链表-02.png">

<ul>
<li>不带头链表：头结点不固定，根据实际需要变换头结点(如在原来头结点前插入新节点，然后，新节点重新作为链表的头结点)。</li>
</ul>
<img src="/images/imageProgramC/链表-03.png">

<p><strong>单向链表、双向链表、循环链表</strong></p>
<ul>
<li>单向链表：</li>
</ul>
<img src="/images/imageProgramC/链表-04.png">

<ul>
<li>双向链表：</li>
</ul>
<img src="/images/imageProgramC/链表-05.png">

<ul>
<li>循环链表：</li>
</ul>
<img src="/images/imageProgramC/链表-06.png">

<h3 id="8-2-链表基本操作"><a href="#8-2-链表基本操作" class="headerlink" title="8.2 链表基本操作"></a>8.2 链表基本操作</h3><h4 id="8-2-1-创建链表"><a href="#8-2-1-创建链表" class="headerlink" title="8.2.1 创建链表"></a>8.2.1 <strong>创建链表</strong></h4><p>使用结构体定义节点类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LINKNODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id; <span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">LINKNODE</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;link_node;</span><br></pre></td></tr></table></figure>

<p>编写函数：<code>link_node* init_linklist()</code></p>
<p>建立带有头结点的单向链表，循环创建结点，结点数据域中的数值从键盘输入，以 -1 作为输入结束标志，链表的头结点地址由函数值返回.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LINKNODE</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">LINKNODE</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;link_node;</span><br><span class="line"></span><br><span class="line"><span class="function">link_node *<span class="title">init_linklist</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//创建头结点指针</span></span><br><span class="line">	link_node* head = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//给头结点分配内存</span></span><br><span class="line">	head = (link_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link_node));</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	head-&gt;data = <span class="number">-1</span>;</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//保存当前节点</span></span><br><span class="line">	link_node* p_current = head;</span><br><span class="line">	<span class="keyword">int</span> data = <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">//循环向链表中插入节点</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"please input data:\n"</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;data);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果输入-1，则退出循环</span></span><br><span class="line">		<span class="keyword">if</span> (data == <span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//给新节点分配内存</span></span><br><span class="line">		link_node* newnode = (link_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link_node));</span><br><span class="line">		<span class="keyword">if</span> (newnode == <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//给节点赋值</span></span><br><span class="line">		newnode-&gt;data = data;</span><br><span class="line">		newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">//新节点入链表，也就是将节点插入到最后一个节点的下一个位置</span></span><br><span class="line">		p_current-&gt;next = newnode;</span><br><span class="line">		<span class="comment">//更新辅助指针p_current</span></span><br><span class="line">		p_current = newnode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-2-遍历链表"><a href="#8-2-2-遍历链表" class="headerlink" title="8.2.2 遍历链表"></a>8.2.2 遍历链表</h4><p>编写函数：<code>void foreach_linklist(link_node* head)</code></p>
<p>顺序输出单向链表各项结点数据域中的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foreach_linklist</span><span class="params">(link_node* head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//赋值指针变量</span></span><br><span class="line">	link_node* p_current = head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p_current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,p_current-&gt;data);</span><br><span class="line">		p_current = p_current-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-3-插入节点"><a href="#8-2-3-插入节点" class="headerlink" title="8.2.3 插入节点"></a>8.2.3 <strong>插入节点</strong></h4><p>编写函数: <code>void insert_linklist(link_node* head,int val,int data).</code></p>
<p>在指定值后面插入数据data,如果值val不存在，则在尾部插入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在值val前插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_linklist</span><span class="params">(link_node* head, <span class="keyword">int</span> val, <span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//两个辅助指针</span></span><br><span class="line">	link_node* p_prev = head;</span><br><span class="line">	link_node* p_current = p_prev-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p_current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (p_current-&gt;data == val)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p_prev = p_current;</span><br><span class="line">		p_current = p_prev-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果p_current为NULL，说明不存在值为val的节点</span></span><br><span class="line">	<span class="keyword">if</span> (p_current == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"不存在值为%d的节点!\n"</span>,val);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建新的节点</span></span><br><span class="line">	link_node* newnode = (link_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link_node));</span><br><span class="line">	newnode-&gt;data = data;</span><br><span class="line">	newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//新节点入链表</span></span><br><span class="line">	newnode-&gt;next = p_current;</span><br><span class="line">	p_prev-&gt;next = newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-4-删除节点"><a href="#8-2-4-删除节点" class="headerlink" title="8.2.4 删除节点"></a>8.2.4 <strong>删除节点</strong></h4><p>编写函数: <code>void remove_linklist(link_node* head,int val)</code></p>
<p>删除第一个值为val的结点.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除值为val的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_linklist</span><span class="params">(link_node* head,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//辅助指针</span></span><br><span class="line">	link_node* p_prev = head;</span><br><span class="line">	link_node* p_current = p_prev-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找值为val的节点</span></span><br><span class="line">	<span class="keyword">while</span> (p_current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (p_current-&gt;data == val)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p_prev = p_current;</span><br><span class="line">		p_current = p_prev-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果p_current为NULL，表示没有找到</span></span><br><span class="line">	<span class="keyword">if</span> (p_current == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//删除当前节点： 重新建立待删除节点(p_current)的前驱后继节点关系</span></span><br><span class="line">	p_prev-&gt;next = p_current-&gt;next;</span><br><span class="line">	<span class="comment">//释放待删除节点的内存</span></span><br><span class="line">	<span class="built_in">free</span>(p_current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-5-销毁链表"><a href="#8-2-5-销毁链表" class="headerlink" title="8.2.5 销毁链表"></a>8.2.5 <strong>销毁链表</strong></h4><p>编写函数: <code>void destroy_linklist(link_node* head)</code></p>
<p>销毁链表，释放所有节点的空间.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//销毁链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_linklist</span><span class="params">(link_node* head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//赋值指针</span></span><br><span class="line">	link_node* p_current = head;</span><br><span class="line">	<span class="keyword">while</span> (p_current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="comment">//缓存当前节点下一个节点</span></span><br><span class="line">		link_node* p_next = p_current-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p_current);</span><br><span class="line">		p_current = p_next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九、函数指针"><a href="#九、函数指针" class="headerlink" title="九、函数指针"></a>九、函数指针</h2><h3 id="9-1-函数类型"><a href="#9-1-函数类型" class="headerlink" title="9.1 函数类型"></a>9.1 函数类型</h3><p>通过什么来区分两个不同的函数？</p>
<p>一个函数在编译时被分配一个入口地址，这个地址就称为函数的指针，<strong>函数名代表函数的入口地址</strong>。</p>
<p>函数三要素： 名称、参数、返回值。C语言中的函数有自己特定的类型。</p>
<p>c 语言中通过 typedef 为函数类型重命名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;	<span class="comment">// f 为函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span></span>;		<span class="comment">// p 为函数类型</span></span><br></pre></td></tr></table></figure>

<p>这一点和数组一样，因此我们可以用一个指针变量来存放这个入口地址，然后通过该指针变量调用函数。</p>
<p><strong>注意：</strong>通过函数类型定义的变量是不能够直接执行，因为没有函数体。只能通过类型定义一个函数指针指向某一个具体函数，才能调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(p)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	p p1;</span><br><span class="line">	<span class="comment">//p1(10,20); //错误，不能直接调用，只描述了函数类型，但是并没有定义函数体，没有函数体无法调用</span></span><br><span class="line">	p* p2 = my_func;</span><br><span class="line">	p2(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//正确，指向有函数体的函数入口地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-函数指针-指向函数的指针"><a href="#9-2-函数指针-指向函数的指针" class="headerlink" title="9.2 函数指针(指向函数的指针)"></a>9.2 函数指针(指向函数的指针)</h3><ul>
<li>函数指针定义方式(先定义函数类型，根据类型定义指针变量);</li>
<li>先定义函数指针类型，根据类型定义指针变量;</li>
<li>直接定义函数指针变量;</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ret:%d\n"</span>, a + b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 先定义函数类型，通过类型定义指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(FUNC_TYPE)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">	FUNC_TYPE* f = my_func;</span><br><span class="line">	<span class="comment">//如何调用？</span></span><br><span class="line">	(*f)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">	f(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 定义函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*FUNC_POINTER)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">	FUNC_POINTER f = my_func;</span><br><span class="line">	<span class="comment">//如何调用？</span></span><br><span class="line">	(*f)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">	f(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 直接定义函数指针变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>(*f)(<span class="keyword">int</span>, <span class="keyword">int</span>) = my_func;</span><br><span class="line">	<span class="comment">//如何调用？</span></span><br><span class="line">	(*f)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">	f(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-函数指针数组"><a href="#9-3-函数指针数组" class="headerlink" title="9.3 函数指针数组"></a>9.3 <strong>函数指针数组</strong></h3><p>函数指针数组，每个元素都是函数指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func01</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"func01:%d\n"</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func02</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"func02:%d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func03</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"func03:%d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">//定义函数指针</span></span><br><span class="line">	<span class="keyword">void</span>(*func_array[])(<span class="keyword">int</span>) = &#123; func01, func02, func03 &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">void</span>(*func_array[<span class="number">3</span>])(<span class="keyword">int</span>);</span><br><span class="line">	func_array[<span class="number">0</span>] = func01;</span><br><span class="line">	func_array[<span class="number">1</span>] = func02;</span><br><span class="line">	func_array[<span class="number">2</span>] = func03;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)&#123;</span><br><span class="line">		func_array[i](<span class="number">10</span> + i);</span><br><span class="line">		(*func_array[i])(<span class="number">10</span> + i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-4-函数指针做函数参数-回调函数"><a href="#9-4-函数指针做函数参数-回调函数" class="headerlink" title="9.4 函数指针做函数参数(回调函数)"></a>9.4 <strong>函数指针做函数参数(回调函数)</strong></h3><p>函数参数除了是普通变量，还可以是函数指针变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形参为普通变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">( <span class="keyword">int</span> x )</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//形参为函数指针变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">( <span class="keyword">int</span>(*p)(<span class="keyword">int</span> a) )</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>函数指针变量常见的用途之一是把指针作为参数传递到其他函数，指向函数的指针也可以作为参数，以实现函数地址的传递。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">caculator</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span>(*func)(<span class="keyword">int</span>,<span class="keyword">int</span>))</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> func(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*FUNC_POINTER)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">caculator</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, FUNC_POINTER func)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> func(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>函数指针和指针函数的区别：</p>
<ul>
<li><p>函数指针是指向函数的指针；</p>
</li>
<li><p>指针函数是返回类型为指针的函数；</p>
</li>
</ul>
<h2 id="十、预处理"><a href="#十、预处理" class="headerlink" title="十、预处理"></a>十、预处理</h2><h3 id="10-1-预处理的基本概念"><a href="#10-1-预处理的基本概念" class="headerlink" title="10.1 预处理的基本概念"></a>10.1 预处理的基本概念</h3><p>C 语言对源程序处理的四个步骤：<strong>预处理、编译、汇编、链接</strong>。</p>
<p>预处理是在程序源代码被编译之前，由预处理器（Preprocessor）对程序源代码进行的处理。这个过程并不对程序的源代码语法进行解析，但它会把源代码分割或处理成为特定的符号为下一步的编译做准备工作。</p>
<h3 id="10-2-文件包含指令-include"><a href="#10-2-文件包含指令-include" class="headerlink" title="10.2 文件包含指令(#include)"></a>10.2 文件包含指令(#include)</h3><p>“文件包含处理”是指一个源文件可以将另外一个文件的全部内容包含进来。Ｃ语言提供了 #include 命令用来实现“文件包含”的操作。</p>
<p><strong>#incude&lt;&gt; 和 #include”” 区别</strong></p>
<ul>
<li><p><strong>“”</strong> 表示系统先在 file1.c 所在的当前目录找 file1.h，如果找不到，再按系统指定的目录检索。</p>
</li>
<li><p><strong>&lt; &gt;</strong> 表示系统直接按系统指定的目录检索。</p>
</li>
</ul>
<p>注意：</p>
<p>​    1. #include &lt;&gt; 常用于包含库函数的头文件；</p>
<p>​    2. #include “” 常用于包含自定义的头文件；</p>
<p>​    3. 理论上 #include 可以包含任意格式的文件(.c .h等) ，但一般用于头文件的包含；</p>
<h3 id="10-3-宏定义"><a href="#10-3-宏定义" class="headerlink" title="10.3 宏定义"></a>10.3 宏定义</h3><h4 id="10-3-1-无参数的宏定义-宏常量"><a href="#10-3-1-无参数的宏定义-宏常量" class="headerlink" title="10.3.1 无参数的宏定义(宏常量)"></a>10.3.1 无参数的宏定义(宏常量)</h4><p>如果在程序中大量使用到了100这个值，那么为了方便管理，我们可以将其定义为：</p>
<p>const int num = 100; 但是如果我们使用num定义一个数组，在不支持c99标准的编译器上是不支持的，因为num不是一个编译器常量，如果想得到了一个编译器常量，那么可以使用：</p>
<p>#define num 100</p>
<p>在编译预处理时，将程序中在该语句以后出现的所有的num都用100代替。这种方法使用户能以一个简单的名字代替一个长的字符串，在预编译时将宏名替换成字符串的过程称为“宏展开”。<strong>宏定义，只在宏定义的文件中起作用</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> r = <span class="number">10.0</span>;</span><br><span class="line">	<span class="keyword">double</span> s = PI * r * r;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"s = %lf\n"</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><p>1)宏名一般用大写，以便于与变量区别；</p>
</li>
<li><p>2) 宏定义可以是常数、表达式等；</p>
</li>
<li><p>3) 宏定义不作语法检查，只有在编译被宏展开后的源程序才会报错；</p>
</li>
<li><p>4) 宏定义不是C语言，不在行末加分号；</p>
</li>
<li><p>5) <strong>宏名有效范围为从定义到本源文件结束</strong>；</p>
</li>
<li><p>6) <strong>可以用#undef命令终止宏定义的作用域</strong>；</p>
</li>
<li><p>7) 在宏定义中，可以引用已定义的宏名；</p>
</li>
</ul>
<h4 id="10-3-2-带参数的宏定义-宏函数"><a href="#10-3-2-带参数的宏定义-宏函数" class="headerlink" title="10.3.2 带参数的宏定义(宏函数)"></a>10.3.2 带参数的宏定义(宏函数)</h4><p>在项目中，经常把一些短小而又频繁使用的函数写成宏函数，这是由于宏函数没有普通函数参数压栈、跳转、返回等的开销，可以调高程序的效率。</p>
<p>宏通过使用参数，可以创建外形和作用都与函数类似地类函数宏(function-like macro). 宏的参数也用圆括号括起来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUM(x,y) ((x)+(y))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//仅仅只是做文本替换 下例替换为 int ret = ((10)+(20));</span></span><br><span class="line">	<span class="comment">//不进行计算</span></span><br><span class="line">	<span class="keyword">int</span> ret = SUM(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ret:%d\n"</span>,ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ul>
<li><p>1) 宏的名字中不能有空格，但是在替换的字符串中可以有空格。ANSI C允许在参数列表中使用空格；</p>
</li>
<li><p>2) 用括号括住每一个参数，并括住宏的整体定义。</p>
</li>
<li><p>3) 用大写字母表示宏的函数名。</p>
</li>
<li><p>4) 如果打算宏代替函数来加快程序运行速度。假如在程序中只使用一次宏对程序的运行时间没有太大提高。</p>
</li>
</ul>
<h3 id="10-4-条件编译"><a href="#10-4-条件编译" class="headerlink" title="10.4 条件编译"></a>10.4 条件编译</h3><p>一般情况下，源程序中所有的行都参加编译。但有时希望对部分源程序行只在满足一定条件时才编译，即对这部分源程序行指定编译条件。</p>
<img src="/images/imageProgramC/条件编译.png">

<p><strong>条件编译</strong></p>
<ul>
<li>防止头文件被重复包含引用；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SOMEFILE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SOMEFILE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要声明的变量、函数</span></span><br><span class="line"><span class="comment">//宏定义</span></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="10-5-一些特殊的预定宏"><a href="#10-5-一些特殊的预定宏" class="headerlink" title="10.5 一些特殊的预定宏"></a>10.5 <strong>一些特殊的预定宏</strong></h3><p>C 编译器，提供了几个特殊形式的预定义宏，在实际编程中可以直接使用，很方便。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	__FILE__			宏所在文件的源文件名 </span></span><br><span class="line"><span class="comment">//	__LINE__			宏所在行的行号</span></span><br><span class="line"><span class="comment">//	__DATE__			代码编译的日期</span></span><br><span class="line"><span class="comment">//	__TIME__			代码编译的时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, __FILE__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, __LINE__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, __DATE__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, __TIME__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十一、动态库的封装和使用"><a href="#十一、动态库的封装和使用" class="headerlink" title="十一、动态库的封装和使用"></a>十一、动态库的封装和使用</h2><h3 id="11-1-库的基本概念"><a href="#11-1-库的基本概念" class="headerlink" title="11.1 库的基本概念"></a>11.1 库的基本概念</h3><p>库是已经写好的、成熟的、可复用的代码。每个程序都需要依赖很多底层库，不可能每个人的代码从零开始编写代码，因此库的存在具有非常重要的意义。</p>
<p>在我们的开发的应用中经常有一些公共代码是需要反复使用的，就把这些代码编译为库文件。</p>
<p>库可以简单看成一组目标文件的集合，将这些目标文件经过压缩打包之后形成的一个文件。像在Windows这样的平台上，最常用的 c 语言库是由集成按开发环境所附带的运行库，这些库一般由编译厂商提供。</p>
<p>库：就是已经编写好的，后续可以直接使用的代码。</p>
<p>c++静态库：会合入到最终生成的程序，<strong>使得结果文件比较大</strong>。优点是不再有任何依赖。</p>
<p>c++动态库：动态库，<strong>一个文件可以多个代码同时使用内存中只有一份，节省内存</strong>，可以随主代码一起编译。缺点是需要头文件。</p>
<p><strong>网友说：库就是除了main函数之外的其他代码，都可以组成库</strong>。</p>
<h3 id="11-2-静态库优缺点"><a href="#11-2-静态库优缺点" class="headerlink" title="11.2 静态库优缺点"></a>11.2 静态库优缺点</h3><ul>
<li><p><strong>静态库对函数库的链接是放在编译时期完成的，静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系</strong>；</p>
</li>
<li><p>程序在运行时与函数库再无瓜葛，移植方便。</p>
</li>
<li><p><strong>浪费空间和资源，所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件</strong>。</p>
</li>
</ul>
<p><strong>内存和磁盘空间</strong></p>
<ul>
<li>静态链接这种方法很简单，原理上也很容易理解，在操作系统和硬件不发达的早期，绝大部门系统采用这种方案。随着计算机软件的发展，这种方法的缺点很快暴露出来，那就是静态链接的方式对于计算机内存和磁盘空间浪费非常严重。特别是多进程操作系统下，静态链接极大的浪费了内存空间。在现在的linux系统中，一个普通程序会用到c语言静态库至少在1MB以上，那么如果磁盘中有2000个这样的程序，就要浪费将近2GB的磁盘空间。</li>
</ul>
<p><strong>程序开发和发布</strong></p>
<ul>
<li>空间浪费是静态链接的一个问题，另一个问题是静态链接对程序的更新、部署和发布也会带来很多麻烦。比如程序中所使用的mylib.lib是由一个第三方厂商提供的，当该厂商更新容量mylib.lib的时候，那么我们的程序就要拿到最新版的mylib.lib，然后将其重新编译链接后，将新的程序整个发布给用户。这样的做缺点很明显，即一旦程序中有任何模块更新，整个程序就要重新编译链接、发布给用户，用户要重新安装整个程序。</li>
</ul>
<p>要解决空间浪费和更新困难这两个问题，最简单的办法就是把程序的模块相互分割开来，形成独立的文件，而不是将他们静态的链接在一起。简单地讲，就是不对哪些组成程序的目标程序进行链接，等程序运行的时候才进行链接。也就是说，<strong>把整个链接过程推迟到了运行时再进行，这就是动态链接的基本思想</strong>。</p>
<h3 id="11-3-Linux-下-gcc-编译器生成和使用静态库和动态库"><a href="#11-3-Linux-下-gcc-编译器生成和使用静态库和动态库" class="headerlink" title="11.3 Linux 下 gcc 编译器生成和使用静态库和动态库"></a>11.3 Linux 下 gcc 编译器生成和使用静态库和动态库</h3><p>我们通常把一些公用函数制作成函数库，供其它程序使用。函数库分为静态库和动态库两种。</p>
<ul>
<li><p>静态库<strong>在程序编译时会被链接并拷贝到目标代码中，程序运行时将不再需要该静态库</strong>。</p>
</li>
<li><p>动态库<strong>在程序编译时并不会被拷贝到目标代码中，而是在程序运行时才被载入</strong>，因此在程序运行时还需要动态库存在。本质上说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。</p>
</li>
</ul>
<p>windows 和 linux 库的二进制是不兼容的（主要是编译器、汇编器和连接器的不同）。</p>
<h4 id="11-3-1-基本概念"><a href="#11-3-1-基本概念" class="headerlink" title="11.3.1 基本概念"></a>11.3.1 基本概念</h4><p><strong>库的种类</strong>：</p>
<p>linux下的库有两种：</p>
<ul>
<li>静态库</li>
<li>共享库（动态库）。</li>
</ul>
<p>二者区别在于代码被载入的时刻不同。静态库的代码在编译过程中已经被载入可执行程序，因此体积较大。共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。</p>
<p><strong>库文件是如何产生的</strong>：</p>
<p>静态库的后缀是 <code>.a</code>，它的产生分两步:</p>
<ul>
<li><p>Step 1. 由源文件编译生成一堆 <code>.o</code>，每个 <code>.o</code> 里都包含这个编译单元的符号表</p>
</li>
<li><p>Step 2. ar 命令将很多 <code>.o</code> 转换成 <code>.a</code>，成为静态库</p>
</li>
</ul>
<p>动态库的后缀是 <code>.so</code>，它由 gcc 加特定参数编译产生。</p>
<p><strong>库文件命名规范</strong>：</p>
<p>库文件一般放在 <code>/usr/local/lib</code>，<code>/usr/lib</code>，<code>/lib</code>，或者其他自定义的 <code>lib</code> 下。</p>
<ul>
<li><p>静态库的名字一般为 <code>libxxxx.a</code>，其中 <code>xxxx</code> 是该 <code>lib</code> 的名称</p>
</li>
<li><p>动态库的名字一般为 <code>libxxxx.so.major.minor</code>， <code>xxxx</code> 是该 <code>lib</code> 的名称，<code>major</code> 是主版本号， <code>minor</code> 是副版本号</p>
</li>
</ul>
<p><strong>如何知道一个可执行程序依赖哪些库</strong>：</p>
<p><code>ldd</code> 命令可以查看一个可执行程序依赖的共享库，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ldd /lib/i386-linux-gnu/libc.so.6</span></span><br><span class="line">/lib/ld-linux.so.2 (0xf7740000)</span><br><span class="line">linux-gate.so.1 =&gt;  (0xf773f000)</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>libc</code> 命令依赖于 <code>linux-gate</code> 库和 <code>ld-linux</code> 库</p>
<p><strong>可执行程序在执行的时候如何定位共享库文件</strong>：</p>
<p>当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统动态载入器(<code>dynamic linker/loader</code>)</p>
<p>对于 <code>elf</code> 格式的可执行程序，是由 <code>ld-linux.so*</code> 来完成的，它先后搜索 <code>elf</code> 文件的 <code>DT_RPATH</code> 段—环境变量 <code>LD_LIBRARY_PATH—/etc/ld.so.cache</code> 文件列表— <code>/lib/,/usr/lib</code> 目录找到库文件后将其载入内存</p>
<p>如：<code>export LD_LIBRARY_PATH=’pwd’</code></p>
<p>将当前文件目录添加为共享目录</p>
<p><strong>在新安装一个库之后如何让系统能够找到他</strong>：</p>
<p>如果安装在 <code>/lib</code> 或者 <code>/usr/lib</code> 下，那么 <code>ld</code> 默认能够找到，无需其他操作。如果安装在其他目录，需要将其添加到 <code>/etc/ld.so.cache</code> 文件中，步骤如下：</p>
<ol>
<li><p>编辑 <code>/etc/ld.so.conf</code> 文件，加入库文件所在目录的路径</p>
</li>
<li><p>运行 <code>ldconfig</code>，该命令会重建 <code>/etc/ld.so.cache</code> 文件</p>
</li>
</ol>
<h4 id="11-3-2-用-gcc-生成静态和动态链接库的示例"><a href="#11-3-2-用-gcc-生成静态和动态链接库的示例" class="headerlink" title="11.3.2 用 gcc 生成静态和动态链接库的示例"></a>11.3.2 用 gcc 生成静态和动态链接库的示例</h4><p>假设有1个类 hello，和一个 main 函数。如下：</p>
<p><strong>hello.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HELLO_H </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_H </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>hello.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello %s!\n"</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>main.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello.h"</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    hello(<span class="string">"world!"</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hello.c 是一个没有 main 函数的 <code>.c</code> 程序，因此不够成一个完整的程序，如果使用 <code>gcc –o</code> 编译并连接它，<code>gcc</code> 将报错，无法通过编译。</p>
<p>前面提过，无论静态库，还是动态库，都是由 <code>.o</code>文件创建的。那么我们如何才能让 main.c 调用 hello 类呢？也就是说该如何才能将 hello.c 通过 gcc 先编译成 <code>.o</code> 文件，并且让 main.c 在编译时能找到它？有三种途径可以实现：</p>
<ul>
<li><p>1）通过编译多个源文件，直接将目标代码合成一个 <code>.o</code> 文件。</p>
</li>
<li><p>2）通过创建静态链接库 <code>libmyhello.a</code>，使得 main 函数调用 hello 函数时可调用静态链接库。</p>
</li>
<li><p>3）通过创建动态链接库 <code>libmyhello.so</code>，使得 main 函数调用 hello 函数时可调用动态链接库。</p>
</li>
</ul>
<h5 id="11-3-2-1-途径一：编译多个源文件"><a href="#11-3-2-1-途径一：编译多个源文件" class="headerlink" title="11.3.2.1 途径一：编译多个源文件"></a>11.3.2.1 途径一：编译多个源文件</h5><p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -c hello.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c main.c</span></span><br></pre></td></tr></table></figure>

<p>这里提醒一下：<code>gcc –o</code> 是将 <code>.c</code> 源文件编译成为一个可执行的二进制代码。而 <code>gcc –c</code> 是使用GNU汇编器将源文件转化为目标代码。更多 gcc 编译选项的常识点<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FyYWNrZXRoaXMvYXJ0aWNsZS9kZXRhaWxzLzQzMzcwMzA3" title="https://blog.csdn.net/arackethis/article/details/43370307">这里<i class="fa fa-external-link"></i></span>。</p>
<p>这时可以看到生成了 hello.o 和 main.o 文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  main.c  main.o</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将两个文件链接成一个 `.o` 文件：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o sayhello main.o hello.o</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看此时已经生成了可执行文件sayhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  main.c  main.o  sayhello</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./sayhello</span></span><br><span class="line">Hello world!!</span><br></pre></td></tr></table></figure>

<h5 id="11-3-2-2-途径二：静态链接库"><a href="#11-3-2-2-途径二：静态链接库" class="headerlink" title="11.3.2.2 途径二：静态链接库"></a>11.3.2.2 途径二：静态链接库</h5><p>静态库文件名是以 lib 为前缀，紧接着是静态库名，扩展名为 <code>.a</code>。例如：我们将创建的静态库名为myhello，则静态库文件名就是 <code>libmyhello.a</code> 。创建静态库用 <code>ar</code> 命令。</p>
<p>删除途径一中生成的3个文件，回到原始的三个文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm hello.o main.o sayhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  main.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始尝试途径二，创建静态库文件libmyhello.a：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c hello.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ar rcs libmyhello.a hello.o</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看一下已经生成了：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  libmyhello.a  main.c</span><br></pre></td></tr></table></figure>

<p>静态库制作完了，如何使用它内部的函数呢？</p>
<p><strong>只需要在使用到这些公用函数的源程序中包含这些公用函数的原型声明，然后在用 gcc 命令生成目标文件时指明静态库名，gcc 将会从静态库中将公用函数连接到目标文件中</strong>。</p>
<p><strong>注意</strong>，gcc 会在静态库名前加上前缀 lib，然后追加扩展名 <code>.a</code> 得到的静态库文件名来查找静态库文件。</p>
<p>因此，我们在写需要连接的库时，只写静态库名就可以，如 <code>libmyhello.a</code> 的库，只写: <code>-lmyhello</code><br>在 main.c 中，我们已包含了该静态库的头文件 hello.h。现在在主程序 main.c 中直接调用它内部的函数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里-L.告诉 gcc 先在当前目录下查找库文件。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o sayhello main.c -static -L. -lmyhello       </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看一下，已经生成可执行文件sayhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  libmyhello.a  main.c  sayhello</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./sayhello</span></span><br><span class="line">Hello world!!</span><br></pre></td></tr></table></figure>

<p>前面提过静态库在编译过程中会被拷贝到目标程序中，运行时不再需要静态库的存在。这里可以简单验证一下：我们删除静态库文件，然后再试着调用函数 hello 看是否还能调用成功。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm libmyhello.a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./sayhello</span></span><br><span class="line">Hello world!!</span><br></pre></td></tr></table></figure>

<p>程序照常运行，静态库中的函数已经被复制到目标程序中了，编译完成后，静态库就没用了，执行时不再需要静态库的存在。</p>
<p><strong>静态链接库的一个缺点是</strong>：</p>
<ul>
<li>如果我们同时运行了许多程序，并且它们使用了同一个库函数，这样，在内存中会大量拷贝同一库函数。这样，就会浪费内存和存储空间。</li>
</ul>
<p>使用了共享链接库的Linux就可以避免这个问题。共享函数库和静态函数在同一个地方，只是后缀不同。比如，在Linux系统，标准的共享数序函数库是 <code>/usr/lib/libm.so</code>。<strong>当一个程序使用共享函数库时，在连接阶段并不把函数代码连接进来，而只是链接函数的一个引用。当最终的函数导入内存开始真正执行时，函数引用被解析，共享函数库的代码才真正导入到内存中</strong>。这样，共享链接库的函数就可以被许多程序同时共享，并且只需存储一次就可以了。<strong>共享函数库的另一个优点是，它可以独立更新，与调用它的函数毫不影响</strong>。</p>
<h5 id="11-3-2-3-途径三：动态链接库（共享函数库）"><a href="#11-3-2-3-途径三：动态链接库（共享函数库）" class="headerlink" title="11.3.2.3 途径三：动态链接库（共享函数库）"></a>11.3.2.3 途径三：动态链接库（共享函数库）</h5><p>动态库文件名和静态库类似，也是在动态库名增加前缀 lib，但其文件扩展名为 <code>.so</code>。例如：我们将创建的动态库名为 myhello，则动态库文件名就是 <code>libmyhello.so</code> 。用 gcc 来创建动态库。</p>
<p>删除途径二中生成的2个文件，回到原始的三个文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm hello.o sayhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  main.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始尝试途径三，创建静态库文件libmyhello.so：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按教程里，会报错：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c hello.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  hello.o  main.c</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared -fPIC -o libmyhello.so hello.o</span></span><br><span class="line">/usr/bin/ld: hello.o: relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC</span><br><span class="line">hello.o: could not read symbols: Bad value</span><br><span class="line">collect2: ld returned 1 exit status</span><br></pre></td></tr></table></figure>

<p>正确方法是，这样就可以了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -fPIC -shared -o libmyhello.so hello.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 已生成libmyhello.so，是绿色。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  libmyhello.so  main.c</span><br></pre></td></tr></table></figure>

<p>最主要的是 GCC 命令行的选项:</p>
<ul>
<li><p><code>-shared</code>：指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接。相当于一个可执行文件</p>
</li>
<li><p><code>-fPIC</code>：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。</p>
</li>
</ul>
<p>下面调用该动态链接库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -o sayhello main.c -L. -lmyhello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello.c  hello.h  libmyhello.so  main.c  sayhello</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./sayhello</span></span><br><span class="line">Hello world!!</span><br><span class="line">成功！</span><br></pre></td></tr></table></figure>

<p>按教程里说的：他以这种方式调用动态链接库出错，找不到动态库文件 <code>libmyhello.so</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sayhello: error while loading shared libraries: libmyhello.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<p>程序在运行时，会在 /usr/lib 和 /lib 等目录中查找需要的动态库文件。若找到，则载入动态库，否则将提示类似上述错误而终止程序运行。解决此类问题有如下三种方法：</p>
<ul>
<li><p>（1）我们将文件 libmyhello.so复制到目录/usr/lib中。</p>
</li>
<li><p>（2）既然连接器会搜寻LD_LIBRARY_PATH所指定的目录，那么我们只要将当前目录添加到环境变量：</p>
<p><code>export LD_LIBRARY_PATH=$(pwd)</code></p>
</li>
<li><p>（3）执行： <code>ldconfig /usr/zhsoft/lib</code></p>
</li>
</ul>
<p>说明：当用户在某个目录下面创建或拷贝了一个动态链接库，若想使其被系统共享，可以执行一下 “ldconfig 目录名” 这个命令。此命令的功能在于让 ldconfig 将指定目录下的动态链接库被系统共享起来，意即：在缓存文件 <code>/etc/ld.so.cache</code> 中追加进指定目录下的共享库。该命令会重建 <code>/etc/ld.so.cache</code> 文件。</p>
<p>参考教程：</p>
<p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlheW91eGpoL2FydGljbGUvZGV0YWlscy83NjAyNzI5" title="http://blog.csdn.net/jiayouxjh/article/details/7602729">http://blog.csdn.net/jiayouxjh/article/details/7602729<i class="fa fa-external-link"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nXzU0ZjgyY2MyMDEwMTE1M3guaHRtbA==" title="http://blog.sina.com.cn/s/blog_54f82cc20101153x.html">http://blog.sina.com.cn/s/blog_54f82cc20101153x.html<i class="fa fa-external-link"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL25hdnlhaWptLmJsb2cuNTFjdG8uY29tLzQ2NDcwNjgvODA5NDI0" title="http://navyaijm.blog.51cto.com/4647068/809424">http://navyaijm.blog.51cto.com/4647068/809424<i class="fa fa-external-link"></i></span></p>
<h2 id="十二、递归函数"><a href="#十二、递归函数" class="headerlink" title="十二、递归函数"></a>十二、递归函数</h2><h3 id="12-1-递归函数基本概念"><a href="#12-1-递归函数基本概念" class="headerlink" title="12.1 递归函数基本概念"></a>12.1 <strong>递归函数基本概念</strong></h3><p>C通过运行时堆栈来支持递归函数的实现。递归函数就是直接或间接调用自身的函数。</p>
<h3 id="12-2-普通函数调用"><a href="#12-2-普通函数调用" class="headerlink" title="12.2 普通函数调用"></a>12.2 普通函数调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funB</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b = %d\n"</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funA</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">	funB(a - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	funA(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的调用流程如下：</p>
<img src="/images/imageProgramC/递归函数.png">

<h3 id="12-3-递归函数调用"><a href="#12-3-递归函数调用" class="headerlink" title="12.3 递归函数调用"></a>12.3 递归函数调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">//中断函数很重要</span></span><br><span class="line">	&#125;</span><br><span class="line">	fun(a - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	fun(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"main\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的调用流程如下：</p>
<img src="/images/imageProgramC/递归函数-01.png">

<p><strong>递归实现给出一个数8793，依次打印千位数字8、百位数字7、十位数字9、个位数字3。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (val == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ret = val / <span class="number">10</span>;</span><br><span class="line">	recursion(ret);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d "</span>,val % <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-4-递归实现字符串反转"><a href="#12-4-递归实现字符串反转" class="headerlink" title="12.4 递归实现字符串反转"></a>12.4 递归实现字符串反转</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse1</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (str == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (*str == <span class="string">'\0'</span>) &#123;  <span class="comment">// 函数递归调用结束条件</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	reverse1(str + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c"</span>, *str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;  <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse2</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (str == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( *str == <span class="string">'\0'</span> ) &#123;	<span class="comment">// 函数递归调用结束条件</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	reverse2(str + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">strncat</span>(buf, str, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse3</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">char</span> *dst)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (str == <span class="literal">NULL</span> || dst == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*str == <span class="string">'\0'</span>) &#123;		<span class="comment">// 函数递归调用结束条件</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	reverse3(str + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">strncat</span>(dst, str, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-5-递归实现链表逆序打印"><a href="#12-5-递归实现链表逆序打印" class="headerlink" title="12.5 递归实现链表逆序打印"></a>12.5 递归实现链表逆序打印</h3><p>TODO</p>
<h2 id="十三、面向接口编程"><a href="#十三、面向接口编程" class="headerlink" title="十三、面向接口编程"></a>十三、面向接口编程</h2><h3 id="13-1-案例背景"><a href="#13-1-案例背景" class="headerlink" title="13.1 案例背景"></a>13.1 案例背景</h3><p>一般的企业信息系统都有成熟的框架。软件框架一般不发生变化，能自由的集成第三方厂商的产品。</p>
<h3 id="13-2-案例需求"><a href="#13-2-案例需求" class="headerlink" title="13.2 案例需求"></a>13.2 案例需求</h3><p>要求在企业信息系统框架中集成第三方厂商的socket通信产品和第三方厂商加密产品。软件设计要求：模块要求松、接口要求紧。</p>
<h3 id="13-3-案例要求"><a href="#13-3-案例要求" class="headerlink" title="13.3 案例要求"></a>13.3 案例要求</h3><ul>
<li><p>1）能支持多个厂商的 socket 通信产品入围</p>
</li>
<li><p>2）能支持多个第三方厂商加密产品的入围</p>
</li>
<li><p>3）企业信息系统框架不轻易发生框架</p>
</li>
</ul>
<h3 id="13-4-编程提示"><a href="#13-4-编程提示" class="headerlink" title="13.4 编程提示"></a>13.4 编程提示</h3><ul>
<li><p>1）抽象通信接口结构体设计（CSocketProtocol）</p>
</li>
<li><p>2）框架接口设计（framework）</p>
</li>
<li><p>3）   a) 通信厂商1入围（CSckImp1）  b) 通信厂商2入围（CSckImp2）</p>
</li>
<li><p>4）   a) 抽象加密接口结构体设计（CEncDesProtocol） b) 升级框架函数（增加加解密功能）  c) 加密厂商1入围(CHwImp)、加密厂商2入围(CCiscoImp)</p>
</li>
<li><p>5）框架接口分文件</p>
</li>
</ul>

      
    </div>

    

    
    
    

    <footer class="post-footer">
      

      <div>    
        
        
            <ul class="post-copyright">
            <li class="post-copyright-author">
                <strong>本文作者：</strong>Mr.Miaow
            </li>
            <li class="post-copyright-link">
                <strong>本文链接：</strong>
                <a href="/2016/05/24/Program-C/program-c-advance/" title="C 进阶">2016/05/24/Program-C/program-c-advance/</a>
            </li>
            <li class="post-copyright-license">
                <strong>版权： </strong>
                本站文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议，请勿用于商业，转载注明出处！
            </li>
            </ul>
        
      </div>
    
      

      
        
      
      
        <div>
          <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
      	<a href="/images/wechatpay.jpg" class="fancybox fancybox.image" rel="group">
          <img id="wechat_qr" src="/images/wechatpay.jpg" alt="Mr.Miaow 微信支付">
	</a>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
      	<a href="/images/alipay.jpg" class="fancybox fancybox.image" rel="group">
          <img id="alipay_qr" src="/images/alipay.jpg" alt="Mr.Miaow 支付宝">
	</a>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

        </div>
      

      
        <div class="post-tags">
          
            <a href="/tags/c-c/" rel="tag"> <i class="fa fa-tag"></i> c/c++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/05/10/Program-C/program-c/" rel="next" title="C 基础">
                <i class="fa fa-chevron-left"></i> C 基础
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/06/03/Program-C/数据结构/" rel="prev" title="数据结构">
                数据结构 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="gitalk-container">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
      
      
        
            <ul class="sidebar-nav motion-element">
                <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
                    文章目录
                </li>
                <li class="sidebar-nav-overview" data-target="site-overview-wrap">
                    站点概览
                </li>
            </ul>
        
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <!-- 添加头像链接 -->
            <a href="/about">
              
                <img class="site-author-image" itemprop="image" src="http://wx4.sinaimg.cn/orj360/e9d04169ly1fde7jy4bquj20ek0hf7gh.jpg" alt="Mr.Miaow">
              
                <p class="site-author-name" itemprop="name">Mr.Miaow</p>
            </a>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">74</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">28</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pYW9wZWk=" title="GitHub &rarr; https://github.com/miaopei"><i class="fa fa-fw fa-github"></i>GitHub</span>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/miaopei163@163.com" title="E-Mail &rarr; miaopei163@163.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          <link rel="stylesheet" href="/dist/APlayer.min.css">
          <div id="aplayer"></div>
          <script type="text/javascript" src="/dist/APlayer.min.js"></script>
          <script type="text/javascript" src="/dist/music.js"></script>

          

          
          

          
            
          
          

        </div>
      </div>

      
        
        <!--noindex-->
            <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
                <div class="post-toc">

                
                    
                

                
                    <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-语言进阶"><span class="nav-number">1.</span> <span class="nav-text">C 语言进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、-内存分区"><span class="nav-number">1.1.</span> <span class="nav-text">一、 内存分区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、指针强化"><span class="nav-number">1.2.</span> <span class="nav-text">二、指针强化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-野指针和空指针"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 野指针和空指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-空指针"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">2.1.1 空指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-野指针"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">2.1.2 野指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-间接访问操作符"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 间接访问操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-指针的步长"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 指针的步长</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-指针的意义-间接赋值"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 指针的意义_间接赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-指针做函数参数"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.5 指针做函数参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-字符串指针强化"><span class="nav-number">1.2.6.</span> <span class="nav-text">2.6 字符串指针强化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-1-一级指针易错点"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">2.6.1 一级指针易错点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-const使用"><span class="nav-number">1.2.7.</span> <span class="nav-text">2.7 const使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、指针的指针-二级指针"><span class="nav-number">1.3.</span> <span class="nav-text">三、指针的指针(二级指针)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-二级指针做形参输出特性"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 二级指针做形参输出特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-二级指针做形参输入特性"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 二级指针做形参输入特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、位运算"><span class="nav-number">1.4.</span> <span class="nav-text">四、位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-位逻辑运算符"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 位逻辑运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-移位运算符"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2 移位运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、多维数组"><span class="nav-number">1.5.</span> <span class="nav-text">五、多维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-一维数组"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1 一维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-数组和指针"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">5.1.1 数组和指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-作为函数参数的数组名"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">5.1.2 作为函数参数的数组名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-多维数组"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2 多维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-指针数组-元素为指针"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">5.2.1 指针数组(元素为指针)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-总结"><span class="nav-number">1.5.3.</span> <span class="nav-text">5.3 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、结构体"><span class="nav-number">1.6.</span> <span class="nav-text">六、结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-结构体基础知识"><span class="nav-number">1.6.1.</span> <span class="nav-text">6.1 结构体基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-结构体嵌套指针"><span class="nav-number">1.6.2.</span> <span class="nav-text">6.2 结构体嵌套指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-结构体成员偏移量"><span class="nav-number">1.6.3.</span> <span class="nav-text">6.3 结构体成员偏移量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-结构体字节对齐"><span class="nav-number">1.6.4.</span> <span class="nav-text">6.4 结构体字节对齐</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-1-内存对齐原因"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">6.4.1 内存对齐原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-2-如何内存对齐"><span class="nav-number">1.6.4.2.</span> <span class="nav-text">6.4.2 如何内存对齐</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、文件操作"><span class="nav-number">1.7.</span> <span class="nav-text">七、文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-文件的操作"><span class="nav-number">1.7.1.</span> <span class="nav-text">7.1 文件的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-文件打开关闭"><span class="nav-number">1.7.2.</span> <span class="nav-text">7.2 文件打开关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-读写配置文件"><span class="nav-number">1.7.3.</span> <span class="nav-text">7.3 读写配置文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八、链表"><span class="nav-number">1.8.</span> <span class="nav-text">八、链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-链表基本概念"><span class="nav-number">1.8.1.</span> <span class="nav-text">8.1 链表基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-1-有关结构体的自身引用"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">8.1.1 有关结构体的自身引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-2-链表节点"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">8.1.2 链表节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-3-链表的分类"><span class="nav-number">1.8.1.3.</span> <span class="nav-text">8.1.3 链表的分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-链表基本操作"><span class="nav-number">1.8.2.</span> <span class="nav-text">8.2 链表基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-1-创建链表"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">8.2.1 创建链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-2-遍历链表"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">8.2.2 遍历链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-3-插入节点"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">8.2.3 插入节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-4-删除节点"><span class="nav-number">1.8.2.4.</span> <span class="nav-text">8.2.4 删除节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-5-销毁链表"><span class="nav-number">1.8.2.5.</span> <span class="nav-text">8.2.5 销毁链表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九、函数指针"><span class="nav-number">1.9.</span> <span class="nav-text">九、函数指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-函数类型"><span class="nav-number">1.9.1.</span> <span class="nav-text">9.1 函数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-函数指针-指向函数的指针"><span class="nav-number">1.9.2.</span> <span class="nav-text">9.2 函数指针(指向函数的指针)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-函数指针数组"><span class="nav-number">1.9.3.</span> <span class="nav-text">9.3 函数指针数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-函数指针做函数参数-回调函数"><span class="nav-number">1.9.4.</span> <span class="nav-text">9.4 函数指针做函数参数(回调函数)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十、预处理"><span class="nav-number">1.10.</span> <span class="nav-text">十、预处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-预处理的基本概念"><span class="nav-number">1.10.1.</span> <span class="nav-text">10.1 预处理的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-文件包含指令-include"><span class="nav-number">1.10.2.</span> <span class="nav-text">10.2 文件包含指令(#include)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-宏定义"><span class="nav-number">1.10.3.</span> <span class="nav-text">10.3 宏定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-1-无参数的宏定义-宏常量"><span class="nav-number">1.10.3.1.</span> <span class="nav-text">10.3.1 无参数的宏定义(宏常量)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-2-带参数的宏定义-宏函数"><span class="nav-number">1.10.3.2.</span> <span class="nav-text">10.3.2 带参数的宏定义(宏函数)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-条件编译"><span class="nav-number">1.10.4.</span> <span class="nav-text">10.4 条件编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-一些特殊的预定宏"><span class="nav-number">1.10.5.</span> <span class="nav-text">10.5 一些特殊的预定宏</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十一、动态库的封装和使用"><span class="nav-number">1.11.</span> <span class="nav-text">十一、动态库的封装和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-库的基本概念"><span class="nav-number">1.11.1.</span> <span class="nav-text">11.1 库的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-静态库优缺点"><span class="nav-number">1.11.2.</span> <span class="nav-text">11.2 静态库优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-Linux-下-gcc-编译器生成和使用静态库和动态库"><span class="nav-number">1.11.3.</span> <span class="nav-text">11.3 Linux 下 gcc 编译器生成和使用静态库和动态库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-1-基本概念"><span class="nav-number">1.11.3.1.</span> <span class="nav-text">11.3.1 基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-2-用-gcc-生成静态和动态链接库的示例"><span class="nav-number">1.11.3.2.</span> <span class="nav-text">11.3.2 用 gcc 生成静态和动态链接库的示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#11-3-2-1-途径一：编译多个源文件"><span class="nav-number">1.11.3.2.1.</span> <span class="nav-text">11.3.2.1 途径一：编译多个源文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-3-2-2-途径二：静态链接库"><span class="nav-number">1.11.3.2.2.</span> <span class="nav-text">11.3.2.2 途径二：静态链接库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-3-2-3-途径三：动态链接库（共享函数库）"><span class="nav-number">1.11.3.2.3.</span> <span class="nav-text">11.3.2.3 途径三：动态链接库（共享函数库）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十二、递归函数"><span class="nav-number">1.12.</span> <span class="nav-text">十二、递归函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-递归函数基本概念"><span class="nav-number">1.12.1.</span> <span class="nav-text">12.1 递归函数基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-普通函数调用"><span class="nav-number">1.12.2.</span> <span class="nav-text">12.2 普通函数调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-递归函数调用"><span class="nav-number">1.12.3.</span> <span class="nav-text">12.3 递归函数调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-4-递归实现字符串反转"><span class="nav-number">1.12.4.</span> <span class="nav-text">12.4 递归实现字符串反转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-5-递归实现链表逆序打印"><span class="nav-number">1.12.5.</span> <span class="nav-text">12.5 递归实现链表逆序打印</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十三、面向接口编程"><span class="nav-number">1.13.</span> <span class="nav-text">十三、面向接口编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#13-1-案例背景"><span class="nav-number">1.13.1.</span> <span class="nav-text">13.1 案例背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-2-案例需求"><span class="nav-number">1.13.2.</span> <span class="nav-text">13.2 案例需求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-3-案例要求"><span class="nav-number">1.13.3.</span> <span class="nav-text">13.3 案例要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-4-编程提示"><span class="nav-number">1.13.4.</span> <span class="nav-text">13.4 编程提示</span></a></li></ol></li></ol></li></ol></div>
                

                </div>
            </div>
        <!--/noindex-->
        
      


      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <!--<i class="fa fa-user"></i>-->
    <i class="fa fa-heart" aria-hidden="true" style="color:red"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Miaow</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">1.1m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">17:21</span>
  

</div>


   <div>
   <span id="sitetime"></span>
   <span id="year" style="display:none">2016</span> 
   <span id="month" style="display:none">12</span>   
   <span id="day" style="display:none">23</span>   
   <span id="hour" style="display:none">15</span>   
   <span id="minute" style="display:none">0</span>   
   <span id="second" style="display:none">0</span>   
	<script language="javascript">
	function siteTime(){        
		window.setTimeout("siteTime()", 1000);
		var seconds = 1000;
		var minutes = seconds * 60;
		var hours = minutes * 60;
		var days = hours * 24;
		var years = days * 365;
		var today = new Date();
		var todayYear = today.getFullYear();
		var todayMonth = today.getMonth()+1;
		var todayDate = today.getDate();
		var todayHour = today.getHours();
		var todayMinute = today.getMinutes();
		var todaySecond = today.getSeconds();
		/* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
		year - 作为date对象的年份，为4位年份值
		month - 0-11之间的整数，做为date对象的月份
		day - 1-31之间的整数，做为date对象的天数
		hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
		minutes - 0-59之间的整数，做为date对象的分钟数
		seconds - 0-59之间的整数，做为date对象的秒数
		microseconds - 0-999之间的整数，做为date对象的毫秒数 */        
		var year = document.getElementById("year").innerHTML;
		var month = document.getElementById("month").innerHTML;
		var day = document.getElementById("day").innerHTML;
		var hour = document.getElementById("hour").innerHTML;
		var minute = document.getElementById("minute").innerHTML;
		var second = document.getElementById("second").innerHTML;//北京时间2018-2-13 00:00:00
		var t1 = Date.UTC(year,month,day,hour,minute,second); 
		var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
		var diff = t2-t1;
		var diffYears = Math.floor(diff/years);
		var diffDays = Math.floor((diff/days)-diffYears*365);
		var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
		var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
		var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
		if(diffYears==0){
		document.getElementById("sitetime").innerHTML=" 网站已运行 "/*+diffYears+" 年 "*/+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
		} else{
		document.getElementById("sitetime").innerHTML=" 网站已运行 "+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
		}
	}
	//siteTime(document.getElementById("year").innerHTML,document.getElementById("year").innerHTML,document.getElementById("year").innerHTML,document.getElementById("year").innerHTML,document.getElementById("year").innerHTML,0);
	siteTime();
	</script>
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<!--









-->

        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>





  



  






  



  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>











  



  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>

  
  <script src="/lib/reading_progress/reading_progress.js"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>


  
  
  


  <script src="/js/affix.js?v=7.1.1"></script>

  <script src="/js/schemes/pisces.js?v=7.1.1"></script>




  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  
  <script src="/js/exturl.js?v=7.1.1"></script>


  
  
  
    
  

  

  
  
  


  


  
    

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">



<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: '8c7770a2f56149bd67f7',
    clientSecret: '1f8bcd6210eaf36b727bcf0546a16cb68dc9012a',
    repo: 'gitment-comments',
    owner: 'miaopei',
    admin: ['miaopei'],
    id: md5(location.pathname),
    
      language: 'zh-CN',
    
    distractionFreeMode: 'true'
  });
  gitalk.render('gitalk-container');
</script>

  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      document.getElementById(all[i].inputID + '-Frame').parentNode.className += ' has-jax';
    }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
<script>
if ($('body').find('div.pdf').length) {
  $.ajax({
    type: 'GET',
    url: '//cdn.jsdelivr.net/npm/pdfobject@2.1.1/pdfobject.min.js',
    dataType: 'script',
    cache: true,
    success: function() {
      $('body').find('div.pdf').each(function(i, o) {
        PDFObject.embed($(o).attr('target'), $(o), {
          pdfOpenParams: {
            navpanes: 0,
            toolbar: 0,
            statusbar: 0,
            pagemode: 'thumbs',
            view: 'FitH'
          },
          PDFJS_URL: '/lib/pdf/web/viewer.html',
          height: $(o).attr('height') || '500px'
        });
      });
    },
  });
}
</script>


  
<script>
if ($('body').find('pre.mermaid').length) {
  $.ajax({
    type: 'GET',
    url: '//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js',
    dataType: 'script',
    cache: true,
    success: function() {
      mermaid.initialize({
        theme: 'forest',
        logLevel: 3,
        flowchart: { curve: 'linear' },
        gantt: { axisFormat: '%m/%d/%Y' },
        sequence: { actorMargin: 50 }
      });
    }
  });
}
</script>


  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  
  
  
  <script src="/lib/pangu/dist/pangu.min.js?v=3.3"></script>
  <script>pangu.spacingPage();</script>


  

  
<script>
  $('.highlight').not('.gist .highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

  
  
    

    
    <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
    <script>AV.initialize("8my53W9pnVTOdpPvvH1P76YB-gzGzoHsz", "DxtWRruxKOO4SPacKO9Mxe8g");</script>
    <script>
        function showTime(Counter) {
            var query = new AV.Query(Counter);
            var entries = [];
            var $visitors = $(".leancloud_visitors");

            $visitors.each(function () {
                entries.push( $(this).attr("id").trim()  );
            });

            query.containedIn('url', entries);
            query.find()
                .done(function (results) {
                    var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

                    if (results.length === 0) {
                        $visitors.find(COUNT_CONTAINER_REF).text(0);
                        return;
                    }

                    for (var i = 0; i < results.length; i++) {
                        var item = results[i];
                        var url = item.get('url');
                        var time = item.get('time');
                        var element = document.getElementById(url);

                        $(element).find(COUNT_CONTAINER_REF).text(time);

                    }
                    for(var i = 0; i < entries.length; i++) {
                        var url = entries[i];
                        var element = document.getElementById(url);
                        var countSpan = $(element).find(COUNT_CONTAINER_REF);
                        if( countSpan.text() == '' ) {
                            countSpan.text(0);
                        }
                    }

                })
                .fail(function (object, error) {
                    console.log("Error: " + error.code + " " + error.message);
                });
        }

        function addCount(Counter) {
            var $visitors = $(".leancloud_visitors");
            var url = $visitors.attr('id').trim();
            var title = $visitors.attr('data-flag-title').trim();
            var query = new AV.Query(Counter);

            query.equalTo("url", url);
            query.find({
                success: function(results) {
                    if (results.length > 0) {
                        var counter = results[0];
                        counter.fetchWhenSave(true);
                        counter.increment("time");
                        counter.save(null, {
                            success: function(counter) {
                                var $element = $(document.getElementById(url));
                                $element.find('.leancloud-visitors-count').text(counter.get('time'));
                            },
                            error: function(counter, error) {
                                console.log('Failed to save Visitor num, with error message: ' + error.message);
                            }
                        });
                    } else {
                        var newcounter = new Counter();
                        /* Set ACL */
                        var acl = new AV.ACL();
                        acl.setPublicReadAccess(true);
                        acl.setPublicWriteAccess(true);
                        newcounter.setACL(acl);
                        /* End Set ACL */
                        newcounter.set("title", title);
                        newcounter.set("url", url);
                        newcounter.set("time", 1);
                        newcounter.save(null, {
                            success: function(newcounter) {
                                var $element = $(document.getElementById(url));
                                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
                            },
                            error: function(newcounter, error) {
                                console.log('Failed to create');
                            }
                        });
                    }
                },
                error: function(error) {
                    console.log('Error:' + error.code + " " + error.message);
                }
            });
        }

        $(function() {
            var Counter = AV.Object.extend("Counter");
            if ($('.leancloud_visitors').length == 1) {
                addCount(Counter);
            } else if ($('.post-title-link').length > 1) {
                showTime(Counter);
            }
        });
    </script>



  

  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src>
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
